#!/usr/bin/perl -w
use Getopt::long;
use Spreadsheet::WriteExcel;

#dir def
my $log_dir="./out";

#file def
my $report_file="sim_rep.log"

#flag def
my $debug=0;
my $help=0;
my $excel_en=0;

#format def
my $info="[INFO] --";
my $error="[ERROR --]"
my $tab=" "x4;

#out_var def
my @pass_cases;
my @fail_cases;
my @unknown_cases;

#parse the input option
GetOptions(
           'log_dir=s'  ==> \$log_dir,     #The equals sign indicates that this option requires a value. The letter s indicates that this value is an arbitrary string. 
           'excel!'     ==> \$excel_en,
           'verbose!'   ==> \$verbose,
           'debug'      ==> \$debug,
           'help!'       ==> \$help,       #Now, using --verbose on the command line will enable $verbose, as expected. But it is also allowed to use --noverbose, which will disable $verbose by setting its value to 0. 
           );
  #call help_mes
  &help_message if $help;
  
  #call parse_sim
  &parse_sim_logs($log_dir);
  
  #call gen_rpt
  &gen_report($report_file);
  
  #entry sub help
  sub help_message{
             print "\nUsage: perl $0 OPTIONS\n\n";
             print "OPTIONS: \n";
             print "-"x50."\n";
             print "${tab}-log-dir dir_name --specify the directory for output log\n";
             print "${tab}-excel            --generate the log file in excel\n";
             print "${tab}-help             --print help message\n";
             print "${tab}-debug/-verbose   --control to output debug infomation\n";
             print "${tab}-Author:\n"
             print "-"x50."\n";
             exit;
             }
  #entry sub parse_sim
  sub parse_sim_logs{
  #obtain file list
  my $sim_dir=shift;
  print "\n${info} Start to parse the simulation log files in ${sim_dir}";
  
  opendir DH,$sim_dir or die "Cannot open $sim_dir\n";
  
  ##create file list in certain dir
  ##method1:@sim_name = glob ("$sim_dir/*.log");
  ##method2:
  while(my $name=readdir DH){        #readdir Dirhandle return the next filename in scalar context , and list of rest files in array context
            $name="${sim_dir}/${name}";
            push (@sim_files,$names) if $name =~ /\.log$/;
            }
  closedir DH;
  #parse each file in the dir 
  if(!defined $sim_files[0] || $sim_files[0] =~ /^\s*$/) {
             print "${error} No obtaining";
             exit;
             }    
  foreach my $sim_file (@sim_files) {
            my $case_id;
            my $status;
            open (SIM, "<", $sim_file) or die "Cannot open ${sim_file}\n";
            while (defined (my $line = <SIM>)){
                       chomp $line;
                       next if $line =~ s/^\s*$/;
                       $line =~ s/^\s*|\s*$//g;        #delete space 
                       if($line =~ /^#\s*test_id\s*:\s*(\d+)/) {
                                  $case_id =$1;
                       } elsif ($line =~/^#\s*test_status\s*:\s*(\w+)/) {
                                  $status =$1;
                                  $status =~ s/^\s*|\s*$//g;
                                  last;
                      }
            }
           if (defined $case_id && defined $status) {
               if($status =~ /^ok$/i) {
                      push (@pass_cases ,$case_id);
              }elsif ($status =~ /^fail$/i) {
                      push (@fail_cases,$case_id);
              }else {
                      push (@unknown_cases,$case_id);
              }
           }
           close(SIM);
  }
print "${INFO} Complete";
}
  
  #entry gen_rpt
  sub gen_report{
             my $out_file =shift;
             if (!$excel_en) {
                        &gen_txt_report($out_file);
                        }
             else {
                        &gen_excel_report($out_file);
                        }
  }

  sub gen_excel_report {
             my $out_name =shift;
             print "Start to generate excel\n";
             $out_name =~ s/^(.*)\.\w+$/${1}\.xls/;
             my $excel_out =Spreadsheet::WriteExcel->new($out_name);
             my $worksheet =$excel_out->add_worksheet();
             my $format =$excel_out->add_format();
             my %col;
             $format->set_bold();
             $format->set_color('red');
             $format->set_align('center');
             my $red_format =$excel_out->add_format
   }

#if { [regexp -nocase {YES} ${debug}] } {
#} else {
#set_host_options -max_cores 4
#}
#===============================================================================
#  Initialize
#===============================================================================
set compile_register_replication "false"
false
### Source : user setting variable ###
echo "### source file : ${input_dir}/infomation.tcl"
### source file : ./input_dir/infomation.tcl
source -echo -verbose  "${input_dir}/infomation.tcl"
#==============================================================================
#  Design setting
#==============================================================================
### top_module ( Editing is necessary ) ###
set  top_module "r5f523e6a"
r5f523e6a
### library name ( Editing is necessary ) ###
set  std_lib   "MF3TM6_Pss_V2p0_T125"
MF3TM6_Pss_V2p0_T125
#set  wlm_lib   "MF3_CMOS1_2.1V_MAX_WLM"
### RTL list file path ( Editing is necessary ) ###
#-- Use "rtl_list" and the "netlist" exclusively.
#set  rtl_list  {}
#lappend rtl_list  "<rtl_list_file_path>"
### GateNet file path ( Editing is necessary ) ###
#-- Use "rtl_list" and the "netlist" exclusively.
set  netlist  {}
lappend netlist   "../../../../v102/CHIPTOP/synthesis/chiptop_build_0629/netlist/r5f523e6a_gatenet.v"
../../../../v102/CHIPTOP/synthesis/chiptop_build_0629/netlist/r5f523e6a_gatenet.v
#===============================================================================
#  Operation setting
#===============================================================================
### Operation flag [ YES | NO ] ( Editing is necessary ) ###
#set phase    "synthesis"
set phase    "synthesis_dct"
synthesis_dct
#####
#set phase    "build"
#===============================================================================
#  Synthesis setting
#===============================================================================
### dont_use script file_path ( Editing is necessary ) ###
set syn(dont_use_file)      ""
lappend syn(dont_use_file)  "../../../../2_config/setting/v102/99_setting/dont_use/set_dont_use_syn.tcl"
../../../../2_config/setting/v102/99_setting/dont_use/set_dont_use_syn.tcl
### Virtual cell uniquify suffix ( Editing is necessary ) ###
set syn(vc_uniq_suffix)         "r5f523e6a"
r5f523e6a
### sdc script file_path ( Editing is necessary ) ###
set syn(sdc_mode_list)             "./SDC/sdc_mode_list_Def.tcl"
./SDC/sdc_mode_list_Def.tcl
### Outside scan FF Setting ###
set syn(out_scan)               ""
lappend syn(out_scan)           "../../../../2_config/setting/v102/99_setting/out_scan/r5f523e6a_outscan.tcl"
../../../../2_config/setting/v102/99_setting/out_scan/r5f523e6a_outscan.tcl
# lappend syn(out_scan)           ""
### dont_touch script file_path ( Editing is necessary ) ###
set syn(dont_touch_file)        ""
lappend syn(dont_touch_file)        "../../../../2_config/setting/v102/99_setting/dont_touch/r5f523e6a_N2N_dt.tcl"
../../../../2_config/setting/v102/99_setting/dont_touch/r5f523e6a_N2N_dt.tcl
lappend syn(dont_touch_file)        "../../../../2_config/setting/v102/99_setting/dont_touch/r5f523e6a_N2N_so.tcl"
../../../../2_config/setting/v102/99_setting/dont_touch/r5f523e6a_N2N_dt.tcl ../../../../2_config/setting/v102/99_setting/dont_touch/r5f523e6a_N2N_so.tcl
### dont_touch script file_path for "Dont_touch & Size_only check" ( Only 1 file ) ###
set syn(dont_touch_file_forCheck)        "../../../../2_config/setting/v102/99_setting/dont_touch/r5f523e6a_N2N_dt_so.tcl"
../../../../2_config/setting/v102/99_setting/dont_touch/r5f523e6a_N2N_dt_so.tcl
#lappend syn(dont_touch_file_forCheck)        "./r5f52316a_dt_so_v004.tcl"
### dont_touch_network [<pin_inst> | <port_name>] ( Editing is necessary ) ###
set syn(dont_touch_network)     {}
lappend syn(dont_touch_network) { net cpusys/syspf/syres/rst_m1_reg }
{ net cpusys/syspf/syres/rst_m1_reg }
lappend syn(dont_touch_network) { net cpusys/syspf/syres/rst_m2_reg }
{ net cpusys/syspf/syres/rst_m1_reg } { net cpusys/syspf/syres/rst_m2_reg }
lappend syn(dont_touch_network) { net cpusys/dftpf/prpg/prpg_scan_en_out }
{ net cpusys/syspf/syres/rst_m1_reg } { net cpusys/syspf/syres/rst_m2_reg } { net cpusys/dftpf/prpg/prpg_scan_en_out }
### ungroup module script file_path ( Editing is necessary ) ###
set syn(ungroup_file)     {}
# lappend syn(ungroup_file)      "<Ungroup_instance_scr_file_path>"
### remove design ###
# lappend syn(remove_design)     "<Remove_design_module>"
#====[ Recommended setting ]============================================
### register merge [ YES | NO(default) ] ###
set  syn(reg_merg)      "NO"
NO
### Aria optimize iteration count [ <number> (default : 3)]
set  syn(opt_count)     "1"
1
#===============================================================================
#  Clock gating setting
#===============================================================================
### Clock gating insert [ YES(default) | NO ] ###
set cg(insert)          "NO"
NO
### Create scan enable port [ YES(default) | NO ] ###
set cg(create_port)     "NO"
NO
### Scan enable port name [ <port_name> (default : mod_scanen) ] ###
#set cg(port_name)       "cpusys/dftpf/prpg/prpg_scan_en_out"
set cg(port_name)       ""
### ClockGating min_bit_width ###
set cg(min_bitwidth)    "3"
3
### Clock gating prohibition hierarchy [ <instance> ] ( Editing is necessary ) ###
# lappend cg(prohibition)  "<Clock_gating_prohibition_hierarchy>"
### clock gating exclude list file path [ <instance> ] ( Editing is necessary ) ###
# lappend cg(cg_exclude_file)  "<Exclude_clock_gating_register_list_file_path>"
### clock_garing global option [ YES : -global(Default) | NO : no_global ] ###
set cg(global_set)      "YES"
YES
#===============================================================================
#  Directory setting
#===============================================================================
### Directory setting ###
set  directory(log)     "./logs"
./logs
set  directory(rep)     "./reports"
./reports
set  directory(net)     "./netlist"
./netlist
## Remove open Resister [ YES | NO ] ( Editing is necessary ) ###
set syn(remove_open_reg)    "YES"
YES
## Remove constants Resister [ YES | NO ] ( Editing is necessary ) ###
set syn(remove_constants_reg)    "YES"
YES
## Remove unused Clock-Gating [ YES | NO ] ( Editing is necessary ) ###
set syn(remove_unused_clockgating)    "YES"
YES
## Boundary Optimize [ YES | NO ] ( Editing is necessary ) ###
set syn(boundary_opt)    "YES"
YES
### sdc procedure path ( Editing is necessary ) ###
set syn(procedure)                 "./Procedure/r_tcl.dc"
./Procedure/r_tcl.dc
### operating condition file_path ( Editing is necessary ) ###
set syn(operating_condition)       "./set_OPERATIING_COND_FOR_RX23E_LIB_HT.tcl"
./set_OPERATIING_COND_FOR_RX23E_LIB_HT.tcl
### ideal_network [<pin_inst> | <port_name>] ( Editing is necessary ) ###
set syn(ideal_network)     {}
lappend syn(ideal_network) { net cpusys/dftpf/prpg/prpg_scan_en_out }
{ net cpusys/dftpf/prpg/prpg_scan_en_out }
#####
#EOF
### Source : "synopsys.pt_setup" ###
echo "### source file : ${common}/synopsys_dc.setup"
### source file : ../../../../1_common_v2.7/synthesis/synopsys_dc.setup
source -echo -verbose  "${common}/synopsys_dc.setup"
################################################################################
#  synopsys_dc.setup
################################################################################
#===============================================================================
# Environments variable setting
#===============================================================================
set auto_wire_load_selection		  "area_reselect" 
Warning: Variable auto_wire_load_selection is not supported in DC Topographical mode and will be ignored. (OPT-1407)
Error: can't set "auto_wire_load_selection": it is a read-only variable (CMD-024)
true
set enable_recovery_removal_arcs	  "true" 
true
set timing_self_loops_no_skew		  "false" 
false
set timing_clock_gating_propagate_enable  "true"
true
set report_default_significant_digits	  "3"
3
set hdlin_presto_net_name_prefix	  "n"
n
set hdlin_check_no_latch		  "true"
true
set compile_seqmap_propagate_constants	  "false"
false

#===============================================================================
# Set for General Design Compiler Variables
#===============================================================================
set link_force_case "check_reference" ;
check_reference
set write_name_nets_same_as_ports	  "true"
true
set gen_match_ripper_wire_widths	  "true"
true
set gen_cell_pin_name_separator		  "_"
_
set hdlin_ff_always_sync_set_reset	  "false"
false
set timing_clock_gating_propagate_enable  "true"
true
#===============================================================================
# Set for Cache Variables
#===============================================================================
set cache_dir_chmod_octal	"775"
775
set cache_file_chmod_octal	"664"
664
set cache_read			"."
.
set cache_read_info		"true"
true
set cache_write			"."
.
set cache_write_info		"true"
true
#===============================================================================
# Default Variables for BSDCompiler and DFTCompiler
#===============================================================================
set test_default_period		"100.0"
100.0
set test_default_delay		  "0.0"
0.0
set test_default_bidir_delay	  "0.0"
0.0
set test_default_strobe		 "40.0"
40.0
set test_default_strobe_width	  "0.0"
0.0
#===============================================================================
# Variables for rtldrc command(DFTCompiler)
#===============================================================================
set hdlin_enable_rtldrc_info	"true"
true
#===============================================================================
# Set for Bus-Naming Variables
#===============================================================================
set bus_naming_style			{%s[%d]}
%s[%d]
set bus_range_separator_style		":"
:
set bus_extraction_style		{%s[%d:%d]}
%s[%d:%d]
set bus_inference_style			{%s[%d]}
%s[%d]
set bus_dimension_separator_style	{][}
][
set bus_minus_style			"-%d"
-%d
#===============================================================================
# Set for Verilog Interface
#===============================================================================
set hdlin_auto_save_templates		  "false"
false
set hdlin_report_inferred_modules	  "verbose"
Information: Variable 'hdlin_report_inferred_modules' has been consolidated under the variable 'hdlin_reporting_level'. (INFO-108)
Information: Use of Variable 'hdlin_report_inferred_modules' is not recommended. This variable will be obsolete in a future release. (INFO-101)
verbose
set change_names_dont_change_bus_members  "true"
true
set verilogout_higher_designs_first	  "true"
true
set verilogout_no_tri			  "true"
true
set verilogout_single_bit		  "false"
false
set verilogout_show_unconnected_pins	  "true"
true
define_design_lib WORK -path ./WORK ;
1
#===============================================================================
# Utility commands path setting
#===============================================================================
lappend auto_path {
/common/appl/Synopsys/synthesis/2015.06-sp4/auxx/tcllib/lib/tcl8.5 /common/appl/Synopsys/synthesis/2015.06-sp4/auxx/tcllib/snps_tcl /common/appl/Synopsys/synthesis/2015.06-sp4/auxx/tcllib/syn /common/appl/Synopsys/synthesis/2015.06-sp4/auxx/tcllib/lib /common/appl/Synopsys/synthesis/2015.06-sp4/linux64/syn/lib /common/appl/Synopsys/synthesis/2015.06-sp4/auxx/gui /common/appl/Synopsys/synthesis/2015.06-sp4/auxx/gui/common /common/appl/Synopsys/synthesis/2015.06-sp4/auxx/gui/syn/layout /common/appl/Renesas/REAP/R2010.09/tools/designcompiler/config/utilities }
#EOF
### Source : Library setting ###
echo "### source file : ${input_dir}/library_setting.tcl"
### source file : ./input_dir/library_setting.tcl
source -echo -verbose  "${input_dir}/library_setting.tcl"
#===============================================================
# Library setting
#===============================================================
### search_path setting ###
set search_path {
    [format %s%s $synopsys_root "/libraries/syn" ]
...   
}
### synthetic_library setting ###
set synthetic_library {
    "standard.sldb"
    "dw_foundation.sldb"
}

    "standard.sldb"
    "dw_foundation.sldb"

### link_library setting ###
set link_library { "*"
    "dw_foundation.sldb"
...   
}
 "*"

### target_library setting ###
set target_library {
... 
}

### Mod for DCT 
if { [regexp -nocase {synthesis_dct} ${phase} ] } {
 echo "### source file : ${input_dir}/library_setting_mw.tcl"
 source -echo -verbose  "${input_dir}/library_setting_mw.tcl"
}
### source file : ./input_dir/library_setting_mw.tcl
#===============================================================
# MW Library setting
#===============================================================
set tech_file
set tlu_plus_worst 
set map_file 
set mw_reference_library [ list      ]

set mw_logic1_net "VDD"
VDD
set mw_logic0_net "VSS"
VSS
sh rm -rf ./Design_MW
set mw_design_library ./Design_MW
./Design_MW
create_mw_lib -technology $tech_file -mw_reference_library $mw_reference_library $mw_design_library
open_mw_lib $mw_design_library

{Design_MW}
set_tlu_plus_files -max_tluplus $tlu_plus_worst -tech2itf_map $map_file
1
unset tech_file
#unset tlu_plus_worst
#unset tlu_plus_best
#unset map_file
#####
### symbol_library setting ###
set symbol_library 	"${std_lib}"

### Set SVF file ###
echo "###  set svf file name : $directory(net)/${top_module}.svf"
###  set svf file name :
set_svf "$directory(net)/${top_module}.svf"
1
### Define : Environment variable (common) ###
set sh_continue_on_error	"false"
false
set edifout_netlist_only	"true"
true
set edifout_no_array		"true"
true
set hdlin_no_group_register	"true"
Information: Use of Variable 'hdlin_no_group_register' is not recommended. This variable will be obsolete in a future release. (INFO-101)
true
set test_enable_dft_drc		"true"
true
set hdlin_preserve_sequential	"true"
true
set test_stil_netlist_format	"verilog"
verilog
set timing_input_port_default_clock		"true"
true
set insert_test_design_naming_style 		"%s_%d"
%s_%d
set compile_preserve_subdesign_interfaces	"true"
true
### Mod for DCT
#set compile_delete_unloaded_sequential_cells	"false"
#####
set hdlin_latch_always_async_set_reset	"true"
true
### Define : Environment variable ( identify_shift_registers ) ###
if { [info exists syn(ident_shift_reg)] && [regexp -nocase {YES} $syn(ident_shift_reg)] } {
    set compile_seqmap_identify_shift_registers  "true"
    set compile_seqmap_identify_shift_registers_with_synchronous_logic "false"

} else {
    set compile_seqmap_identify_shift_registers  "false"
    set compile_seqmap_identify_shift_registers_with_synchronous_logic "false"
}
false
### Define : additional Environment variable : for synthesis ###
if { [regexp -nocase {syn} ${phase}] } {
    echo "### Add Environment variable : for Synthesis"
    set timing_self_loops_no_skew			"false"
    set compile_disable_hierarchical_inverter_opt       "true"
    set compile_sequential_area_recovery		"true"
}
### Add Environment variable : for Synthesis
Information: Variable 'compile_sequential_area_recovery' is obsolete and is being ignored. (INFO-100)
true
### Mod for DCT
## Remove open Resister ###
if { [regexp -nocase {YES} $syn(remove_open_reg)] } {
    echo "### Remove unloaded_sequential_cells ###"
    set compile_delete_unloaded_sequential_cells "true"
} else {
    set compile_delete_unloaded_sequential_cells "false"
}
### Remove unloaded_sequential_cells ###
true
## Remove constants Resister """
if { [regexp -nocase {YES} $syn(remove_constants_reg)] } {
    echo "### Remove constants FF ###"
    set compile_seqmap_propagate_constants "true"
} else {
    set compile_seqmap_propagate_constants "false"
}
### Remove constants FF ###
true
set timing_enable_multiple_clocks_per_reg true
true
#####
echo "start_time" >  $directory(rep)/dc_time_detail.rep
date              >> $directory(rep)/dc_time_detail.rep
#===============================================================================
#  Read & Link design
#===============================================================================
### Read RTL ###
if { [info exists rtl_list] && ![regexp {^$} ${rtl_list}] } {
    echo "### Read RTL : ${rtl_list}"

    #-- Read RTL list --#
    echo "#-- Read RTL list file --#"
    set tmp_list	""

    foreach list_file ${rtl_list} {
	set ifile [open ${list_file} r]
	while { [gets ${ifile} line] > -1 } {
	    if { [regexp {^#}  ${line}] } { continue }
	    if { [regexp {^//} ${line}] } { continue }
	    if { [regexp {^--} ${line}] } { continue }
	    if { [regexp {^$}  ${line}] } { continue }
	    lappend tmp_list ${line}
	}
	close  ${ifile}
    }

    #-- Analyze --#
    echo "#-- Analyze RTL --#"
    redirect -tee $directory(rep)/rep.read_design {
	analyze -f verilog ${tmp_list}
    }

    #-- Elaborate ---#
    elaborate -architecture verilog ${top_module}

### Read Netlist ###
} elseif { [info exists netlist] && ![regexp {^$} ${netlist}] } {
    redirect -tee $directory(rep)/rep.read_design {
	read_verilog -netlist ${netlist}
    }

### Error stop ###
} else {
    echo "###"
    echo "### Error !! ###"
    echo "###"
    echo "    Please set Input design...."
    echo ""
    exit
}
1
#===============================================================================
#  uniquify
#===============================================================================
### Uniquify for virtual cell ###
if { [regexp -nocase {syn} ${phase}] } {

    echo "### Uniquify for virtual cell"
    set virtual_cell_col  [get_cells -h * -f "@ref_name=~*_cell_pf* OR @ref_name=~ux099smc*"]

    if { [sizeof_collection ${virtual_cell_col}] > 0 } {
	set uniquify_naming_style [format "%s%s%s" "%s_" $syn(vc_uniq_suffix) "_%d"]
	uniquify  -cell  ${virtual_cell_col}
    }
}
1
### Uniquify naming style : common ###
echo "### Uniquify"
### Uniquify
set uniquify_naming_style "%s_%d"
%s_%d
uniquify
Information: Uniquified 10 instances of design 'PAQBE0E44SC_wrp'. (OPT-1056)
Information: Uniquified 2 instances of design 'PAQB5VTOLPUPC_wrp'. (OPT-1056)
Information: Uniquified 18 instances of design 'ux113kioglue0'. (OPT-1056)
1

#===============================================================================
#  Multi-Mode Setting 
#===============================================================================
source -e -v $syn(sdc_mode_list)
lappend sdc_mode_list { user2 ./SDC/sdc_r5f523e6a_top_Def.tcl ./SDC/sdc_r5f523e6a_top_user2_v2.tcl }
{ user2 ./SDC/sdc_r5f523e6a_top_Def.tcl ./SDC/sdc_r5f523e6a_top_user2_v2.tcl }
{ user2 ./SDC/sdc_r5f523e6a_top_Def.tcl ./SDC/sdc_r5f523e6a_top_user2_v2.tcl }
if {[info exists syn(sdc_mode_list)] && ![regexp {^$} $syn(sdc_mode_list)]} {
    foreach sdc_mode_info $sdc_mode_list {
        set  mode          [lindex ${sdc_mode_info} 0]
        set  common_sdc    [lindex ${sdc_mode_info} 1]
        set  mode_sdc      [lindex ${sdc_mode_info} 2]

    create_scenario ${mode}
    source -echo -verbose $syn(operating_condition)
    set_operating_conditions WORST_TREE -library ${std_lib}

    set_tlu_plus_files      -max_tluplus ${tlu_plus_worst}      -tech2itf_map ${map_file}

    set_preferred_routing_direction                 -layers {M1 M3 M5} -direction horizontal
    set_preferred_routing_direction                 -layers {M2 M4} -direction vertical

    set_max_leakage_power 0

    set voltage "2.1v"
    set PROPAGATE_VALUE false
    source -echo -verbose $syn(procedure)

    ### Read SDC ###
    echo "### Read SDC : common"
    source -echo -verbose  "${common_sdc}"
    echo "### Read SDC : mode"
    source -echo -verbose  "${mode_sdc}"

    report_scenarios
  }
}
set_attribute [get_libs  ] nom_temperature 125.000
#create
create_operating_conditions -name WORST_TREE_NEW -library   -process 1.00 -voltage 2.000 -temperature 125.000 
1
#remove
remove_attribute [get_libs  ] default_operating_conditions
set_attribute [get_libs  ] default_operating_conditions WORST_TREE_NEW
proc r_get_top_net {target_pin} {
  set net [get_nets -q -of_objects $target_pin]
  set i 1
  while {$i > 0} {
    set i 0
    set net_name [get_attribute $net full_name]
    foreach_in_collection net2 [get_nets -q -of_objects $net_name] {
      if {$net_name != [get_attribute $net2 full_name]} {
        set net $net2
        incr i
      }
    }
  }
  return [get_attribute $net full_name]
}
proc r_get_up_inst {target_pin len} {
  set cell [get_cell -quiet -of_objects $target_pin]
  set len_full [string length [get_attribute $cell full_name]]
  set len_base [string length [get_attribute $cell name]]
  set string_end [expr $len_full - $len_base -2 ]
  while {[expr $string_end+2] > $len} {
    set cell [get_cell [string range [get_attribute $cell full_name] 0 $string_end] ]
    set len_full [string length [get_attribute $cell full_name]]
    set len_base [string length [get_attribute $cell name]]
    set string_end [expr $len_full - $len_base -2]
  }
  return [get_attribute $cell full_name]
}
proc r_get_cellpin { target_pin_string } {
  set target_pin {} 
  foreach each_pin_string $target_pin_string {
    set target_pin_add [get_net -quiet "$each_pin_string $each_pin_string[*]"]
    set target_pin [add_to_collection $target_pin $target_pin_add]
  }
  set c_i [list [current_instance .]]
  current_instance >> /dev/null
  set return_primitive_pin {}
  if { [sizeof_collection $target_pin] != 0 } {
    foreach_in_collection each_target_net $target_pin {
      set each_target_pin [get_pin -quiet [get_attribute $each_target_net full_name]]
      set each_target_port [get_port -quiet [get_attribute $each_target_net full_name]]
      if { [sizeof_collection $each_target_pin] != 0 } {
        set pin_int_input {}
        set pin_int_output {}
        set pin_ext_input {}
        set pin_ext_output {}
        set target_pin_name [get_attribute $each_target_pin full_name]
        set connect_pin [get_pin -l -of $target_pin_name]
        foreach_in_collection each_connect_pin $connect_pin {
          set target_inst [get_cell -of $each_target_pin]
          set target_inst_name [get_attribute $target_inst full_name]
          set len_target_inst [string length $target_inst_name]
          set inst_connect_pin [r_get_up_inst $each_connect_pin $len_target_inst]
          if {$inst_connect_pin == $target_inst_name} {
            set flag_int_ext "in"
          } else {
            set flag_int_ext "out"
          }
          # echo $inst_connect_pin $target_inst_name
          if {$flag_int_ext == "in"} {
            if {[get_attribute $each_connect_pin direction]=="in"} {
              set pin_int_input [add_to_collection $pin_int_input $each_connect_pin]
              # echo [get_attribute $each_connect_pin full_name] "AAA"
            }
            if {[get_attribute $each_connect_pin direction]=="out"} {
              set pin_int_output [add_to_collection $pin_int_output $each_connect_pin]
              # echo [get_attribute $each_connect_pin full_name] "AA2"
            }
            if {[get_attribute $each_connect_pin direction]=="inout"} {
              set pin_int_input [add_to_collection $pin_int_input $each_connect_pin]
              set pin_int_output [add_to_collection $pin_int_output $each_connect_pin]
              # echo [get_attribute $each_connect_pin full_name] "AA3"
            }
          } else {
            if {[get_attribute $each_connect_pin direction]=="in"} {
              set pin_ext_input [add_to_collection $pin_ext_input $each_connect_pin]
              # echo [get_attribute $each_connect_pin full_name] "AA4"
            }
            if {[get_attribute $each_connect_pin direction]=="out"} {
              set pin_ext_output [add_to_collection $pin_ext_output $each_connect_pin]
              # echo [get_attribute $each_connect_pin full_name] "AA5"
            }
            if {[get_attribute $each_connect_pin direction]=="inout"} {
              set pin_ext_input [add_to_collection $pin_ext_input $each_connect_pin]
              set pin_ext_output [add_to_collection $pin_ext_output $each_connect_pin]
              # echo [get_attribute $each_connect_pin full_name] "AA6"
            }
          }
        }
        foreach_in_collection each_connect_port [get_port -q [r_get_top_net $each_target_pin]] {
          if {[get_attribute $each_connect_port direction]=="out"} {
            set pin_ext_input [add_to_collection $pin_ext_input $each_connect_port]
          }
          if {[get_attribute $each_connect_port direction]=="in"} {
            set pin_ext_output [add_to_collection $pin_ext_output $each_connect_port]
          }
          if {[get_attribute $each_connect_port direction]=="inout"} {
            set pin_ext_input [add_to_collection $pin_ext_input $each_connect_port]
            set pin_ext_output [add_to_collection $pin_ext_output $each_connect_port]
          }
        }
        if {[sizeof_collection $pin_int_input] == 0} {
          set return_primitive_pin [add_to_collection $return_primitive_pin $pin_int_output]
        } elseif {[sizeof_collection $pin_ext_input] == 0} {
          set return_primitive_pin [add_to_collection $return_primitive_pin $pin_ext_output]
        } elseif {[sizeof_collection $pin_int_output] == 0} {
          set return_primitive_pin [add_to_collection $return_primitive_pin $pin_int_input]
        } elseif {[sizeof_collection $pin_ext_output] == 0} {
          set return_primitive_pin [add_to_collection $return_primitive_pin $pin_ext_input]
        } else {
          echo "Error: Not move target_pin"
        }
        # echo [sizeof_collection $pin_int_input] [sizeof_collection $pin_int_output]
        # echo [sizeof_collection $pin_ext_input] [sizeof_collection $pin_ext_output]
      } elseif { [sizeof_collection $each_target_port] != 0 } {
        set return_primitive_pin [add_to_collection $return_primitive_pin $each_target_port]
      } else {
        echo "Error : Dont set net!!  r_get_cellpin(" $target_pin_string ")"
      }
    }
  } else {
      echo "Error :  Nothing matched!!  r_get_cellpin(" $target_pin_string ")"
  }
  if {$c_i != "{}"} {
    current_instance $c_i
  }
  return $return_primitive_pin
}
### Read SDC : common
######################################
# Apply Physical Design Constraints
######################################
set mw_site_name_mapping "CORE unit006"
CORE unit006

extract_physical_constraints .def.gz
Information: Completed COMPONENTS section (DDEFR-040)
Information: Parsing PINS section (DDEFR-038)
Information: Completed PINS section (DDEFR-040)
Information: Parsing BLOCKAGES section (DDEFR-038)
Information: Completed BLOCKAGES section (DDEFR-040)
Information: Parsing SPECIALNETS section (DDEFR-038)
Information: Completed SPECIALNETS section (DDEFR-040)
Information: Parsing NETS section (DDEFR-038)
Information: Completed NETS section (DDEFR-040)
1
##############################
### DONT TOUCH
##############################
set_dont_touch [get_cell "" ] true
1

##############################
### KEEP BOUNDARY
##############################
set_boundary_optimization [get_cell "" ] false
1

1
### Read SDC : mode
# 0_variable_define_user2_RX23E_A_v0.02.tcl
# 1.1_case_analysis_user2_RX23E_A_v0.02.tcl
# 1.2_create_clock_user2_RX23E_A_v0.02.tcl
# 1.3_set_clock_latency_user2_RX23E_A_v0.02.tcl
# 1.4_clock_sense_user2_RX23E_A_v0.02.tcl
# 1.6_clock_gating_check_user2_RX23E_A_v0.02.tcl
# 2.1_clock_false_user2_RX23E_A_v0.02.tcl
# 2.2_set_clock_uncertainty_user2_RX23E_A_v0.02.tcl
# 3_false_setting_user2_RX23E_A_v0.02.tcl
# 4_multicycle_setting_user2_RX23E_A_v0.02.tcl
# 5_external_delay_user2_RX23E_A_v0.02.tcl
# 6_min_max_delay_user2_RX23E_A_v0.02.tcl
# 7.2_disable_clock_gating_user2_RX23E_A_v0.02.tcl
# 7.3_max_borrow_user2_RX23E_A_v0.02.tcl
# 7_disable_timing_user2_RX23E_A_v0.02.tcl
# ==========================================
#   0. variable define

# ==========================================
#-------------------------
#-------------------------
#-- Vriable No. Vari- 1 
#-------------------------
if { ${voltage} == "2.1v" } {
    set clk_margin  0.1 
}
0.1
if { ${voltage} == "1.8v" } {
    set clk_margin  0.04 
}
#-------------------------
#-------------------------
#-- Vriable No. Vari- 2 
#-------------------------
if { ${voltage} == "2.1v" } {
    set clk_period1 [expr 20.8 * (1.0 - $clk_margin)]
}
18.72
if { ${voltage} == "1.8v" } {
    set clk_period1 [expr 60 * (1.0 - $clk_margin)]
}
#-------------------------
#-------------------------
#-- Vriable No. Vari- 3 
#-------------------------
if { ${voltage} == "2.1v" } {
    set clk_period2 [expr 31.25 * (1.0 - $clk_margin)]
}
28.125
if { ${voltage} == "1.8v" } {
    set clk_period2 [expr 120 * (1.0 - $clk_margin)]
}
#-------------------------
#-------------------------
#-- Vriable No. Vari- 4 
#-------------------------
if { ${voltage} == "2.1v" } {
    set pclk2_period [expr ($clk_period1 * 2)]
}
37.44
#-------------------------
#-------------------------
#-- Vriable No. Vari- 6 
#-------------------------
if { ${PROPAGATE_VALUE} == "true" } {
    set fact_val  1 
}
if { ${PROPAGATE_VALUE} == "false" } {
    set fact_val  1 
}
1
#-------------------------
#-------------------------
#-- Vriable No. Vari- 7 
#-------------------------
if { ${voltage} == "2.1v" } {
    set clk_qx_rspcki_a_period  [expr 40 * (1.0 - $clk_margin)]
}
36.0
if { ${voltage} == "1.8v" } {
    set clk_qx_rspcki_a_period  [expr 40 * (1.0 - $clk_margin)]
}
#-------------------------
#-------------------------
#-- Vriable No. Vari-inst_1
#-------------------------
if { ${voltage} == "2.1v" } {
    set shier_inst 
}
if { ${voltage} == "1.8v" } {
    set  
}
#-------------------------
#-------------------------
#-- Vriable No. Vari-PORT-1
#-------------------------
if { ${voltage} == "2.1v" } {
    set FINEC_SOURCE 
}
if { ${voltage} == "1.8v" } {
    set FINEC_SOURCE 
}
#-------------------------
#-------------------------
#-- Vriable No. Vari-PORT-2
#-------------------------
if { ${voltage} == "2.1v" } {
    set TCK_SOURCE 
}
if { ${voltage} == "1.8v" } {
    set TCK_SOURCE 
}
#-------------------------
#-------------------------
#-- Vriable No. Vari-PORT-3
#-------------------------
if { ${voltage} == "2.1v" } {
    set EDT_SOURCE 
}
if { ${voltage} == "1.8v" } {
    set EDT_SOURCE 
}
#-------------------------
# ==========================================
#   1.1 Mode Setting
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/10/2018
# ==========================================
#-------------------------
#-- Case No. CASE-mode_1
#-------------------------
set_case_analysis  0      ""
1
1
# ==========================================
#   1.2 Clock Information
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/10/2018
# ==========================================
set pl_plclk_period [expr ${clk_period2}*${fact_val}]
28.125
set os_moscclk_period [expr [expr $clk_period1*2.0   ]*${fact_val}]
37.44
set oli_hococlk_period [expr ${clk_period2}*${fact_val}]
28.125
set fihfl_hococlk_period [expr ${clk_period2}*${fact_val}]
28.125
set lo_lococlk_period [expr [expr $clk_period1*12.0  ]*${fact_val}]
224.64
set ilo_ilococlk_period [expr [expr $clk_period1*20.0   ]*${fact_val}]
374.4
set pt_fineclkin_period [expr [expr $clk_period1*2.0   ]*${fact_val}]
37.44
set pt_tck_period [expr [expr $clk_period1*6.0   ]*${fact_val}]
112.32
set pt_edtclk_period [expr [expr $clk_period1*6.0   ]*${fact_val}]
112.32
set selclk_tock_period [expr ${clk_period1}*${fact_val}]
18.72
set selclk_cntck_period [expr [expr $clk_period1*20.0   ]*${fact_val}]
374.4
set qx_rspcki_a_PH3_period [expr  [expr $clk_qx_rspcki_a_period ]*${fact_val}]
36.0
set qx_rspcki_a_PC5_period [expr  [expr $clk_qx_rspcki_a_period ]*${fact_val}]
36.0
#-------------------------
#-------------------------
#-- Clock No. CLK- 1 
#-------------------------
create_clock -add     -name    -period ${pl_plclk_period}     -waveform [list 0.0 [expr $clk_period2 / 2.0 ] ]     [get_pins /pll1/ ]
1
#-------------------------
#-------------------------
#-------------------------
#-- Clock No. CLK- 1 
#-------------------------
create_generated_clock -add     -name      -divide_by  1      -combinational     -source [get_pins /pll1/]     -master_clock [get_clocks ]     [get_pins ]
1
#-------------------------
# ==========================================
#   1.3 Clock Latency Setting
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/10/2018
# ==========================================
#-------------------------
#-- Clock No. CLK_Latency- 1 
#-------------------------
set_clock_latency      3      [get_clocks ]
1
# ==========================================
#   1.4 Clock Sense Setting
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/10/2018
# ==========================================
#---------------------------#
#== No. CLOCK SENSE- 1  ==#
#---------------------------#
set_clock_sense     -clocks [get_clocks  ]     -stop_propagation     [get_pins]
#-- EOF --#
# ==========================================
#   2.1 Inter-Clock False Setting
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/16/2018
# ==========================================
#-----------------------------------------
#--- Inter-Clock False Group : 
#-----------------------------------------
set_false_path -from [get_clocks]     -to [get_clocks [list            ]]
1

1
# ==========================================
#-- Eof --#
# ==========================================
#   2.2 Clock Uncertainty Setting
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/10/2018
# ==========================================
#-----------------------------------------
#--- Setup Clock Uncertainty 
#-----------------------------------------
#-----------------------------------------
#--- Clock Uncertainty : pl_plclk to pl_plclk
#-----------------------------------------
set_clock_uncertainty     -from [get_clocks ]     -to [get_clocks ]     -setup      0.2 
1
#-----------------------------------------
#--- Clock Uncertainty : os_moscclk to mckn_div
#-----------------------------------------
set_clock_uncertainty     -from [get_clocks ]     -to [get_clocks]     -hold      0.1 
1
-----------------------------------------
#-- Eof --#
# ==========================================
#   3. False Path Setting
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/14/2018
# ==========================================
#---------------------------#
#== No. FALSE-chip_top-1 ==#
#---------------------------#
set_false_path     -through [get_pins ]     -through [get_pins ]     
# ==========================================
#   4. Multicycle Path Setting
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/10/2018
# ==========================================
#---------------------------#
#== No. MULTI-pericore-crc-1 ==#
#---------------------------#
set_multicycle_path      2      -through [get_pins ]     -through [get_pins ]     -setup     -start 
1
#---------------------------#
#== No. MULTI-pericore-crc-2 ==#
#---------------------------#
set_multicycle_path      1      -through [get_pins ]     -through [get_pins ]     -hold     -start 
# ==========================================
#   5. External Delay Setting
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/10/2018
# ==========================================
# ==========================================
# ==========================================
#   6. Min/Max Delay
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/10/2018
# ==========================================
# ==========================================
# ==========================================
#   7.2 Desable Clock Gating Check Setting
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/10/2018
# ==========================================
# ==========================================
# ==========================================
#   7.3 Max Time Borrow
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/10/2018
# ==========================================
# ==========================================
# ==========================================
#   7.1 Desable Timing Setting
#-- Document Name : RX23E_A
#-- Mode Name : user2
#   Generate by Timing_const_RX23E-A_USER2_v0.02.xlsm
#   Dcument Revision : v0.02
#   Document Auther : RDB_huyuda
#   Document Create Date : 10/4/2018
#   Generate at 5/10/2018
# ==========================================
#---------------------------#
#== No. DISABLE TIMING-temp-sdc-765 ==#
#---------------------------#
set_disable_timing     -from A -to Y [get_cells ]
1

1
# ==========================================
****************************************
Report : scenarios
Design :
Scenario(s): user2
****************************************

All scenarios (Total=1): user2
All Active scenarios (Total=1): user2
Current scenario     : user2

Scenario #0: user2 is active.
Scenario options: Setup Hold
Cts_corner: none
Has timing derate: No

Library(s) Used:

Operating condition(s) Used:
  Analysis Type    : bc_wc
  Max Operating Condition: :WORST_TREE
  Max Process    : 1.00
  Max Voltage    : 2.00
  Max Temperature: 125.00
  Min Operating Condition: :WORST_TREE
  Min Process    : 1.00
  Min Voltage    : 2.00
  Min Temperature: 125.00

TLU+ Files Used:
  Max TLU+ file: 
  Tech2ITF mapping file: 
### outside scan setting ###
if { [info exists syn(out_scan)] && ![regexp {^$} $syn(out_scan)] } {
    echo "### Outside Scan setting : $syn(out_scan)"
    source "$syn(out_scan)"

    if {[info exists outside_list]} {
        set i 0
        echo "#===============================================================" >  ${directory(rep)}/rep.outside_scan_list
        echo "#  Outside Scan F/F list"                                         >> ${directory(rep)}/rep.outside_scan_list
        echo "#===============================================================" >> ${directory(rep)}/rep.outside_scan_list
    
        foreach outside_inst ${outside_list} {
            echo "### set_scan_element : ${outside_inst}"
            set outside_col [get_cells ${outside_inst}]
            set_scan_element  false  ${outside_col}
    
            foreach_in_collection outside_info ${outside_col} {
                incr i
                echo "${i}\t[get_object ${outside_info}]"   >> $directory(rep)/rep.outside_scan_list
            }
        }
    } else {
        echo "### set_scan_element : No setting ###"
    }
}
### Outside Scan setting : ../../../../2_config/setting/v102/99_setting/out_scan/r5f523e6a_outscan.tcl
### Dont touch setting : external ###
if { [info exists syn(dont_touch_file)] && ![regexp {^$} $syn(dont_touch_file)] } {
    echo "### Dont touch setting : $syn(dont_touch_file)"
    foreach tmp_scr $syn(dont_touch_file) {
        echo "### Dount touch  : $tmp_scr"
            source -echo -verbose  $tmp_scr
        }
    }
### Dont touch setting : ../../../../2_config/setting/v102/99_setting/dont_touch/r5f523e6a_N2N_dt.tcl ../../../../2_config/setting/v102/99_setting/dont_touch/r5f523e6a_N2N_so.tcl
### Dount touch  : ../../../../2_config/setting/v102/99_setting/dont_touch/r5f523e6a_N2N_dt.tcl
#source -e -v  /svhome/os_huyu/SDC_RX23E/v101/dont_touch_CHIP_RX23E_A_v0.03/9.1_Dont_touch_dont-use_H1D_v0.1.tcl

# ==========================================

#   Dont Touch Setting 

# ==========================================

#=================================================

#== NO-       rcn-1

#=================================================

#set_dont_touch [get_cell pericore/mp200/rcn_0/rcan0/ip/rscan_lite_inst/ch_no_0__i_ch_unit_inst/i_dlctop_inst/m_dlc_inst/B0PBX_BAUDRATE/vc_cpg_gated_clock/U1/vc_gtdclk_cell] true#set_interactive_constraint_modes [all_constraint_modes -active]

set_dont_use   [get_lib_cells */*]

1
set_dont_touch [get_lib_cells */*]

1
remove_attribute [get_lib_cells ] dont_touch

remove_attribute [get_lib_cells /*] dont_use  

#==========================================================#

#== Don't Use

#==========================================================#

#==========================================================#

#== Don't Touch

#==========================================================#

#== EOF ==#

### Dont touch setting : for virtual cell
### set_fix_multiple_port_nets : -outputs -constants
### set_attribute sequential_bridging -type boolean : true
# Register list before compile
echo "# Register list before compile" > $directory(rep)/register_before_map.list_tmp
foreach_in_collection buf [all_registers] {
  echo [get_object_name $buf] >> $directory(rep)/register_before_map.list_tmp
}
sh sort $directory(rep)/register_before_map.list_tmp > $directory(rep)/register_before_map.list
sh rm $directory(rep)/register_before_map.list_tmp
set ports_clock_root [filter_collection [get_attribute [all_clocks] sources] object_class==port]
group_path -name REGOUT -to [all_outputs]
1
group_path -name REGIN -from [remove_from_collection [all_inputs] ${ports_clock_root}]
1
group_path -name FEEDTHROUGH -from [remove_from_collection [all_inputs] ${ports_clock_root}] -to [all_outputs]
1
#===============================================================================
#  Get reports Pre N2N
#===============================================================================
if { ![file isdirectory $directory(rep)/Pre_N2N] } {
sh mkdir $directory(rep)/Pre_N2N
}
set directory(rep_pre) $directory(rep)/Pre_N2N
./reports/Pre_N2N
if { [regexp -nocase -- {syn} ${phase}] } {
    echo "### Get reports Pre N2N"

    # Clock Gating report : Pre
    if { [regexp -nocase {YES} $syn(remove_unused_clockgating)] } {
        if {[sizeof_collection [all_clocks]] > 0 } {
        echo "### Identify clock gating"
        identify_clock_gating
        }
    } else {
    }

    ### Clock Gating report ###
    echo "#-- Clock gating report (gated)"
    redirect $directory(rep_pre)/rep.clock_gated_pre	{ report_clock_gating -nosp -gated }
    redirect $directory(rep_pre)/rep.clock_gating_elem_pre  { report_clock_gating -nosp -gating_elements }

    echo "#-- Clock gating report (ungated)"
    redirect $directory(rep_pre)/rep.clock_ungated_pre	{ report_clock_gating -nosp -ungated }

    ### Area report ###
    echo "#-- Area report"
    redirect $directory(rep_pre)/rep.area_synthesis_pre	{ report_area -nosplit }

    ### Report timing ###
    if {[info exists syn(sdc_mode_list)] && ![regexp {^$} $syn(sdc_mode_list)]} {
        foreach sdc_mode_info $sdc_mode_list {
            set  mode          [lindex ${sdc_mode_info} 0]

            current_scenario ${mode}
        #-- Register to Register --#
        echo "#-- Timing report"
        echo "    report : Register to Register"
        redirect $directory(rep_pre)/rep.timing_reg_to_reg_${mode}_pre {
        	report_timing         	    -delay max -path full -max_paths 1 -nworst 1         	    -cap -trans -nets -nos -input -attri
    }
        #-- Register to IO --#
        echo "    report : Register to IO"
        redirect $directory(rep_pre)/rep.timing_reg_to_io_${mode}_pre {
        	report_timing         	    -group REGOUT         	    -delay max -path full -max_paths 1 -nworst 1         	    -cap -trans -nets -nos -input -attri
    }
        #-- IO to Register --#
        echo "    report : IO to Register"
        redirect $directory(rep_pre)/rep.timing_io_to_reg_${mode}_pre {
        	report_timing         	    -group REGIN         	    -delay max -path full -max_paths 1 -nworst 1         	    -cap -trans -nets -nos -input -attri
    }
  }
}

    ### Report Normal-FF ###
    set  normal_ff_col [get_cells -h * -f "@ref_name=~TBDF* OR @ref_name=~TM6DFF*"]

    redirect $directory(rep_pre)/rep.normal_ff_list_pre {
        foreach_in_collection tmp_col ${normal_ff_col} {
            set ff_name  [get_attri [get_cells ${tmp_col}] ref_name]
            set ff_inst  [get_attri [get_cells ${tmp_col}] full_name]

            echo "[format %-16s ${ff_name}]  ${ff_inst}"
        }
    }

}
### Get reports Pre N2N
if { [regexp -nocase {YES} ${debug}] } {
} else {
    if { [info exists syn(exe_mapping)] && [regexp -nocase {NO} $syn(exe_mapping)] } {
       } else {
#===============================================================================
#  Mapping
#===============================================================================
echo "mapping_start_time" >> $directory(rep)/dc_time_detail.rep
date                      >> $directory(rep)/dc_time_detail.rep

    report_scenarios

if { [regexp -nocase {syn} ${phase}] } {
    echo "###         ###"
    echo "### Mapping ###"
    echo "###         ###"

    ### Ideal network ###
    if { [info exists cg(port_name)] && ![regexp {^$} $cg(port_name)] } {
	if {[get_ports $cg(port_name) -quiet] != ""} {
	    echo "### Ideal network : $cg(port_name)"
	    set_ideal_network  [get_ports $cg(port_name)]
	}
    }

    ### dont_touch clock path ###
    if { [sizeof_collection [get_clocks {v_* V_*} -q]] > 0 } {
	set  dont_touch_list  [remove_from_collection [all_clocks] [get_clocks {v_* V_*}]]
    } else {
	set  dont_touch_list  [all_clocks]
    }

    if { [sizeof_collection ${dont_touch_list}] > 0 } {
	echo "#### Dont touch network : ${dont_touch_list}"
	set_dont_touch_network  ${dont_touch_list}
    }

    ### max area setting ###
    set_max_area 0

    ### 1st Mapping ###
    echo "### Compile ultra : for Mapping"

### Mod for DCT
#    if { [regexp -nocase {YES} $syn(boundary_opt)] } {
#        compile_ultra #	-spg #    	-no_autoungroup #    	-no_seq_output_inversion #    	-area_high_effort_script
#       } else {
#        compile_ultra #        -no_boundary_optimization #    	-no_autoungroup #    	-no_seq_output_inversion #    	-area_high_effort_script
#       }

    ### Remove unconnected ports ###
    echo "### remove_unconnected_ports"
    remove_unconnected_ports [get_cells -h *]

	#-- Get reports --#
	redirect         $directory(rep)/rep.area_mapping  { report_area -nosplit }
	redirect         $directory(rep)/rep.mapping       { report_design }
	redirect -append $directory(rep)/rep.mapping       { check_design }
	redirect -append $directory(rep)/rep.mapping       { report_constraints -verbose }
	redirect -append $directory(rep)/rep.mapping       { report_clock_gating -hier -gating_elements -gated }
}

echo "mapping_end_time" >> $directory(rep)/dc_time_detail.rep
date                    >> $directory(rep)/dc_time_detail.rep
       }

#===============================================================================
#  Optimize
#===============================================================================
    report_scenarios

if { [info exists syn(opt_count)] && $syn(opt_count) > 0 } {
    echo "###          ###"
    echo "### Optimize ###"
    echo "###          ###"

    ### Optimize : Area Recovery ###
    for { set i 0 } { ${i} < $syn(opt_count) } { incr i } {
	echo "###                       ###"
        echo "### Area Recovery [expr ${i} + 1] start ###"
        echo "###                       ###"
 
    echo "optimize_start_time_${i}" >> $directory(rep)/dc_time_detail.rep
    date                            >> $directory(rep)/dc_time_detail.rep

	### Compile_ultra ###
    if { [regexp -nocase {YES} $syn(boundary_opt)] } {
	compile_ultra 	-spg  	-incremental 	-no_autoungroup 	-no_seq_output_inversion 	-area_high_effort_script
       } else {
	compile_ultra  	-incremental 	-no_boundary_optimization 	-no_autoungroup 	-no_seq_output_inversion 	-area_high_effort_script
       }

    report_qor > myResult/bef_qor.rpt 				
report_area -hierarchy > myResult/bef_area.rpt 				
    optimize_netlist -area				
report_area -hierarchy > myResult/aft_qor.rpt 				
    report_qor >  myResult/aft_area.rpt				


	### Get reports ###
	    redirect         $directory(rep)/rep.area_optimize_${i} { report_area -nosplit }
	    redirect         $directory(rep)/rep.optimize_${i}	{ report_design }
	    redirect -append $directory(rep)/rep.optimize_${i}	{ report_clock }
	    redirect -append $directory(rep)/rep.optimize_${i}	{ check_design }
	    redirect -append $directory(rep)/rep.optimize_${i}	{ report_constraint -verbose }

    echo "optimize_end_time_${i}" >> $directory(rep)/dc_time_detail.rep
    date                          >> $directory(rep)/dc_time_detail.rep
    }
}


#===============================================================================
#  Write verilog
#===============================================================================
### Define naming rule ###
define_name_rules APB -replacement_char "_"
define_name_rules APB -type port -max_length 255 -allowed "A-Z a-z 0-9 [] _ "
define_name_rules APB -type net  -max_length 255 -allowed "A-Z a-z 0-9 [] _ "
define_name_rules APB -type cell -max_length 255 -allowed "A-Z a-z 0-9 _ "
define_name_rules APB -first_restricted "0-9 _"
define_name_rules APB -case_insensitive

### Change naming rule ###
change_names -rules APB     -hierarchy
change_names -rules verilog -hierarchy -verbose

### Remove design ###
if { [info exists syn(remove_design)] && ![regexp {^$} $syn(remove_design)] } {
    echo "### Remove design"

    foreach remove_name $syn(remove_design) {
	echo "#-- Remove design : ${remove_name}"
	remove_design -hierarchy ${remove_name}
    }
}

### Measures of wired_and ###
set store_current [ current_design ]

foreach_in_collection design_name [ find design "*" ] {
    current_design $design_name
    set net_name [filter [find net "*"] "@wired_and==true"]
    if { [get_object_name $net_name] != {} } {
        remove_attribute [find net $net_name] wired_and
    }
}

current_design $store_current


### Write Verilog ###
write -format verilog -hierarchy -output $directory(net)/${top_module}_gatenet.v ${top_module}

### Mod for DCT
### Write DDC ###
write -format ddc -hierarchy -output  $directory(net)/${top_module}.ddc ${top_module}
#####

### Write SDC ###
if { [info exists syn(sdc_file)] && ![regexp {^$} $syn(sdc_file)] } {
    write_sdc  $directory(net)/${top_module}.sdc
}

#===============================================================================
#  Get reports after N2N
#===============================================================================
if { [regexp -nocase -- {syn} ${phase}] } {
    echo "### Get reports"

    ### Identify clock gating ###
    if {[sizeof_collection [all_clocks]] > 0 } {
        echo "### Identify clock gating"
        identify_clock_gating
    }

    ### Clock Gating report ###
    echo "#-- Clock gating report (gated)"
    redirect $directory(rep)/rep.clock_gated	{ report_clock_gating -nosp -gated }
    redirect $directory(rep)/rep.clock_gating_elem  { report_clock_gating -nosp -gating_elements }

    echo "#-- Clock gating report (ungated)"
    redirect $directory(rep)/rep.clock_ungated	{ report_clock_gating -nosp -ungated }

    ### Area report ###
    echo "#-- Area report"
    redirect $directory(rep)/rep.area_synthesis	{ report_area -nosplit }

    ### Synthesis report ###
    echo "#-- Synthesis report"
    redirect         $directory(rep)/rep.synthesis { report_design }
    redirect -append $directory(rep)/rep.synthesis { report_clock }
    redirect -append $directory(rep)/rep.synthesis { check_design }
    redirect -append $directory(rep)/rep.synthesis { report_constraint -verbose }

    ### Report timing ###
    if {[info exists syn(sdc_mode_list)] && ![regexp {^$} $syn(sdc_mode_list)]} {
        foreach sdc_mode_info $sdc_mode_list {
            set  mode          [lindex ${sdc_mode_info} 0]

            current_scenario ${mode}
        #-- Register to Register --#
        echo "#-- Timing report"
        echo "    report : Register to Register"
        redirect $directory(rep)/rep.timing_reg_to_reg_${mode} {
        	report_timing         	    -delay max -path full -max_paths 1 -nworst 1         	    -cap -trans -nets -nos -input -attri
    }
        #-- Register to IO --#
        echo "    report : Register to IO"
        redirect $directory(rep)/rep.timing_reg_to_io_${mode} {
        	report_timing         	    -group REGOUT         	    -delay max -path full -max_paths 1 -nworst 1         	    -cap -trans -nets -nos -input -attri
    }
        #-- IO to Register --#
        echo "    report : IO to Register"
        redirect $directory(rep)/rep.timing_io_to_reg_${mode} {
        	report_timing         	    -group REGIN         	    -delay max -path full -max_paths 1 -nworst 1         	    -cap -trans -nets -nos -input -attri
    }
  }
}

    ### Report Normal-FF ###
    set  normal_ff_col [get_cells -h * -f "@ref_name=~TBDF* OR @ref_name=~TM6DFF*"]

    redirect $directory(rep)/rep.normal_ff_list {
        foreach_in_collection tmp_col ${normal_ff_col} {
            set ff_name  [get_attri [get_cells ${tmp_col}] ref_name]
            set ff_inst  [get_attri [get_cells ${tmp_col}] full_name]

            echo "[format %-16s ${ff_name}]  ${ff_inst}"
        }
    }

}

### Print Massage Info ###
echo "#-- Print Massage Info"
redirect         $directory(rep)/rep.print_message_info { print_message_info }
#added 20180411 to write sdc
write_sdc -version 1.7  out_netlist.sdc

# Register list after compile & Optimize
echo "# Register list after optimize" > $directory(rep)/register_after_opt.list_tmp
foreach_in_collection buf [all_registers] {
  echo [get_object_name $buf] >> $directory(rep)/register_after_opt.list_tmp
}
sh sort $directory(rep)/register_after_opt.list_tmp > $directory(rep)/register_after_opt.list
sh rm $directory(rep)/register_after_opt.list_tmp

echo "end_time" >> $directory(rep)/dc_time_detail.rep
date            >> $directory(rep)/dc_time_detail.rep
source -e -v ./user_custom.tcl
#===============================================================================
#  Quit
#===============================================================================
    quit
}





##### Start automatically set file path to script directory path.
set ASTC_scr_name [ info script ] 
set ASTC_SCR_DIR  [ file dirname $ASTC_scr_name ]
##### End
set ASTC_REP_DIR "${rep_ac_dir}/rep_${run_mode}_${COND}_${CHK_TYPE}"
set ASTC_REP_OPT "-significant_digits 6 -derate -nets -input_pins -nosplit -path_type full_clock_expanded"
set ASTC_PATH_OPT ""
#set COND ""
set ASTC_PATH_MAX "10000"
set ASTC_REP_MAX "100"
if {![file isdirectory $ASTC_REP_DIR]} {
   file mkdir "$ASTC_REP_DIR";
   echo "Make directory $ASTC_REP_DIR"
}

set astc_format_val(max) "-10000"
set astc_format_val(min) "10000"
set astc_sort_direction(max) "decreasing"
set astc_sort_direction(min) "increasing"
set astc_less_or_greater(max) ">"
set astc_less_or_greater(min) "<"
source $ASTC_SCR_DIR/proc/astc_path_calc.proc;
source $ASTC_SCR_DIR/proc/analyze_rep_cmd.proc;
source $ASTC_SCR_DIR/proc/rep_exec_time.proc;
set astc_log_splitter_l "#--------------------------------------------------------------------------------------------------"
set astc_log_splitter_m "#---------------------------------------------------"
set astc_log_splitter_s "#------------------------------"
echo "### Start verification for \"$ASTC_SCR_DIR/check/Kobetsu_RX23E_A_DSAD_atc_check.tcl\". \[[date]\]"
if { [info exists astc_format_val] == 0 } {
   echo " ---> *** ASTC ERROR0005: Please read astc_config.tcl first."
}
#-----------------------------------------------------------
#-- Start Header settings
#-----------------------------------------------------------
   set ASTC_REP_FILE "Kobetsu_RX23E_A_DSAD_${COND}"
   set astc_check_path_num 0;
   set astc_check_fail_num 0;
#-----------------------------------------------------------
#-- End   Header settings
#-----------------------------------------------------------
### Format varibles for calculation
   ### for "rise_dsad_0_clk_osx4"
   set rise_dsad_0_clk_osx4_end_setup "$astc_format_val(max)"
   set rise_dsad_0_clk_osx4_end_hold  "$astc_format_val(max)"
   set rise_dsad_0_clk_osx4_max   "$astc_format_val(max)"
   set rise_dsad_0_clk_osx4_min   "$astc_format_val(min)"
   set rise_dsad_0_clk_osx4_end_setup_err 0
   set rise_dsad_0_clk_osx4_end_hold_err  0
   set rise_dsad_0_clk_osx4_max_err   0
   set rise_dsad_0_clk_osx4_min_err   0
#----------------------------
#-- Start get path timing
#----------------------------
echo "#--- report results \[[date]\]" > ${ASTC_REP_DIR}/${ASTC_REP_FILE}.rep
echo "#--- report results \[[date]\]" > ${ASTC_REP_DIR}/${ASTC_REP_FILE}.rep_worst
   echo "#--------------------------------------------------------------------------------------------------"
   echo "#---- get path timing for Path name \"rise_dsad_0_clk_osx4\""
   echo "#--------------------------------------------------------------------------------------------------"
   foreach Delay_type { max min } {
      set astc_path_info "#---- Path name \"rise_dsad_0_clk_osx4_${Delay_type}\" 1 of 1"
      set astc_rep_info "#---- report_timing -delay_type ${Delay_type}  -from \[ get_pins { pericore/mp200/dsad_0/coretop/kernelpgac/clkctl/clkosx4_reg_reg/Q* }] -through \[get_pins { pericore/mp200/dsad_0/dsad_clk_osx4 }] -rise_to \[get_pins  pericore/anatop/afeh/DS0CLKOSX4 ] $ASTC_REP_OPT $ASTC_PATH_OPT"
      echo "$astc_log_splitter_l"
      echo "$astc_path_info"
      echo "$astc_rep_info"
      echo "$astc_log_splitter_l"
      echo "$astc_log_splitter_l" >> ${ASTC_REP_DIR}/${ASTC_REP_FILE}.rep
      echo "$astc_path_info" >> ${ASTC_REP_DIR}/${ASTC_REP_FILE}.rep
      echo "$astc_rep_info" >> ${ASTC_REP_DIR}/${ASTC_REP_FILE}.rep
      echo "$astc_log_splitter_l" >> ${ASTC_REP_DIR}/${ASTC_REP_FILE}.rep
      set ASTC_PATH_NUM_OPT ""
      set rise_dsad_0_clk_osx4_path_attr(${Delay_type}) [eval "get_timing_path -delay ${Delay_type}  -from \[ get_pins { pericore/mp200/dsad_0/coretop/kernelpgac/clkctl/clkosx4_reg_reg/Q* }] -through \[get_pins { pericore/mp200/dsad_0/dsad_clk_osx4 }] -rise_to \[get_pins  pericore/anatop/afeh/DS0CLKOSX4 ] $ASTC_PATH_OPT $ASTC_PATH_NUM_OPT -include_hierarchical_pins"]
      if { $rise_dsad_0_clk_osx4_path_attr(${Delay_type}) == "" } {
         set rise_dsad_0_clk_osx4_path_attr(${Delay_type}) [eval "get_timing_path -delay ${Delay_type}  -from \[ get_pins { pericore/mp200/dsad_0/coretop/kernelpgac/clkctl/clkosx4_reg_reg/Q* }] -through \[get_pins { pericore/mp200/dsad_0/dsad_clk_osx4 }] -rise_to \[get_pins  pericore/anatop/afeh/DS0CLKOSX4 ] $ASTC_PATH_OPT $ASTC_PATH_NUM_OPT -include_hierarchical_pins -slack_lesser_than inf"]
      }
      if { $rise_dsad_0_clk_osx4_path_attr(${Delay_type}) == "" } {
         echo "      ASTC Error: Object path rise_dsad_0_clk_osx4 timing is not reported."
      }
      set astc_path_num [sizeof_collection $rise_dsad_0_clk_osx4_path_attr(${Delay_type})]
      set rise_dsad_0_clk_osx4_dly_tmp2(${Delay_type}) [lindex [lsort -real -$astc_sort_direction($Delay_type) [get_attribute $rise_dsad_0_clk_osx4_path_attr(${Delay_type}) arrival ] ] 0 ]
      set rise_dsad_0_clk_osx4_start_clk_dly(${Delay_type}) [lindex [get_attribute $rise_dsad_0_clk_osx4_path_attr(${Delay_type}) startpoint_clock_latency -quiet ] 0 ]
      if { $rise_dsad_0_clk_osx4_path_attr(${Delay_type}) != "" } {
         if { $astc_path_num > $ASTC_REP_MAX } {
            set astc_path_num $ASTC_REP_MAX
            echo "ASTC WARNING0005 : Path route number of Path name \"rise_dsad_0_clk_osx4\" is over $ASTC_REP_MAX."
            echo "                   Please control report path number by value $ASTC_REP_MAX in astc_config.tcl."
            echo "                   To avoid disk full, report number of *.rep is automatically reduced to \$ASTC_REP_MAX $ASTC_REP_MAX."
         }
         for {set i 1} {$i <= $astc_path_num} {incr i} {
            echo "### Path count. $i" >> ${ASTC_REP_DIR}/${ASTC_REP_FILE}.rep
            eval "report_timing [index_collection $rise_dsad_0_clk_osx4_path_attr(${Delay_type}) [expr $i-1] ] $ASTC_REP_OPT" >> ${ASTC_REP_DIR}/${ASTC_REP_FILE}.rep
         }; #foreach 
      } else {
         echo "---> Object path is not collected." >> ${ASTC_REP_DIR}/${ASTC_REP_FILE}.rep
      }
   }; #foreach ($Delay_type)
   echo "
   ### Timing information for \"rise_dsad_0_clk_osx4\" 1 of 1."
   set rise_dsad_0_clk_osx4_end_setup_tmp [lindex [lsort -real -decreasing [get_attribute $rise_dsad_0_clk_osx4_path_attr(max) endpoint_setup_time_value -quiet ]] 0 ]
   set rise_dsad_0_clk_osx4_end_hold_tmp  [lindex [lsort -real -decreasing [get_attribute $rise_dsad_0_clk_osx4_path_attr(min) endpoint_hold_time_value -quiet ]] 0 ]
   echo "   end lib setup : ${rise_dsad_0_clk_osx4_end_setup_tmp}"
   echo "   end lib hold  : ${rise_dsad_0_clk_osx4_end_hold_tmp}"
   if { [regexp {^[\d.\-e]+$} "$rise_dsad_0_clk_osx4_end_setup_tmp"] == 0 } {
      echo "ASTC WARNING 0001: End library setup value for\"rise_dsad_0_clk_osx4\" is not collected.\n"
      set rise_dsad_0_clk_osx4_end_setup_err 1
   } else {
      if {$rise_dsad_0_clk_osx4_end_setup_tmp == 0 }  {
         echo "ASTC WARNING 0002: \"rise_dsad_0_clk_osx4\" end library setup value is zero.\n"
      };
      if {$rise_dsad_0_clk_osx4_end_setup < $rise_dsad_0_clk_osx4_end_setup_tmp} {
         set rise_dsad_0_clk_osx4_end_setup $rise_dsad_0_clk_osx4_end_setup_tmp
      };
   };
   if { [regexp {^[\d.\-e]+$} "$rise_dsad_0_clk_osx4_end_hold_tmp"] == 0 } {
      echo "ASTC WARNING 0003: End library hold value for \"rise_dsad_0_clk_osx4\" is not collected.\n"
      set rise_dsad_0_clk_osx4_end_hold_err 1
   } else {
      if {$rise_dsad_0_clk_osx4_end_hold_tmp == 0 }  {
         echo "ASTC WARNING 0004: \"rise_dsad_0_clk_osx4\" end library hold value is zero.\n"
      };
      if {$rise_dsad_0_clk_osx4_end_hold < $rise_dsad_0_clk_osx4_end_hold_tmp} {
         set rise_dsad_0_clk_osx4_end_hold $rise_dsad_0_clk_osx4_end_hold_tmp;
      };
   };
   unset rise_dsad_0_clk_osx4_path_attr(${Delay_type})
   echo "   max path delay : $rise_dsad_0_clk_osx4_dly_tmp2(max) ns"
   echo "   min path delay : $rise_dsad_0_clk_osx4_dly_tmp2(min) ns"
   if { [regexp {^[\d.\-e]+$} "$rise_dsad_0_clk_osx4_dly_tmp2(max)"] == 0 || $rise_dsad_0_clk_osx4_dly_tmp2(max) == $astc_format_val(max) } {
      echo "   ASTC Error: Max path delay of \"rise_dsad_0_clk_osx4\" is not collected.\n"
      set rise_dsad_0_clk_osx4_max_err 1
   } else {
      if { $rise_dsad_0_clk_osx4_dly_tmp2(max) == 0 } {
         echo "   ASTC Error: Max path delay is zero.\n"
      };
      if {$rise_dsad_0_clk_osx4_max < $rise_dsad_0_clk_osx4_dly_tmp2(max)} {
         set rise_dsad_0_clk_osx4_max $rise_dsad_0_clk_osx4_dly_tmp2(max);
      };
   };
   if { [regexp {^[\d.\-e]+$} "$rise_dsad_0_clk_osx4_dly_tmp2(min)"] == 0 || $rise_dsad_0_clk_osx4_dly_tmp2(min) == $astc_format_val(min)} {
   echo "   ASTC Error: Min path delay of \"rise_dsad_0_clk_osx4\" is not collected.\n"
      set rise_dsad_0_clk_osx4_min_err 1
   } else {
      if {$rise_dsad_0_clk_osx4_min > $rise_dsad_0_clk_osx4_dly_tmp2(min)} {
         set rise_dsad_0_clk_osx4_min $rise_dsad_0_clk_osx4_dly_tmp2(min);
      };
   };
   echo "
   ### Total timing information for \"rise_dsad_0_clk_osx4\""
   echo "   end lib setup : ${rise_dsad_0_clk_osx4_end_setup}"
   echo "   end lib hold  : ${rise_dsad_0_clk_osx4_end_hold}"
   echo "   max path delay : $rise_dsad_0_clk_osx4_max ns"
   echo "   min path delay : $rise_dsad_0_clk_osx4_min ns"
   echo "   max start clk delay : $rise_dsad_0_clk_osx4_start_clk_dly(max) ns"
   echo "   min start clk delay : $rise_dsad_0_clk_osx4_start_clk_dly(min) ns"
 #----------------------------
#-- End   get path timing
#----------------------------
#----------------------------
#-- Start judge
#----------------------------
   set astc_worst_slack 10000
   echo "--------------------------------------------------"
   echo "----- Start Timing check rule \"R_F_dsad_0_clk_osx4_dly\""
   echo "--------------------------------------------------"
   set path_err_flag 0
   echo "   Timing Rule: rise_dsad_0_clk_osx4_max-fall_dsad_0_clk_osx4_min  < [expr 5] ns"
   if { ${rise_dsad_0_clk_osx4_max_err} == 1 } {
      echo "   ASTC ERROR0001:  rise_dsad_0_clk_osx4_max path delay is not correctly collected."
      set path_err_flag 1
   } else {
      echo "   rise_dsad_0_clk_osx4_max = ${rise_dsad_0_clk_osx4_max} ns"
   }
   if { ${fall_dsad_0_clk_osx4_min_err} == 1 } {
      echo "   ASTC ERROR0001: fall_dsad_0_clk_osx4_min path delay is not correctly collected."
      set path_err_flag 1
   } else {
      echo "   fall_dsad_0_clk_osx4_min = ${fall_dsad_0_clk_osx4_min} ns"
   }
   if { $path_err_flag == 1} {
      echo "   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
      echo "   X   ASTC ERROR0003: A part of delay for Timing rule is not collected."
      echo "   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
      incr astc_check_fail_num
      echo "Kobetsu_RX23E_A_DSAD	,R_F_dsad_0_clk_osx4_dly	,Path fail	,NG,rise_dsad_0_clk_osx4_max-fall_dsad_0_clk_osx4_min  < [expr 5],\" $rise_dsad_0_clk_osx4_max - $fall_dsad_0_clk_osx4_min < [expr 5]\"" >> $ASTC_REP_DIR/Chk_summary_${COND}.csv
   } else {
      set calc_result [expr  $rise_dsad_0_clk_osx4_max - $fall_dsad_0_clk_osx4_min]
      echo "   Left side of timing rule: rise_dsad_0_clk_osx4_max-fall_dsad_0_clk_osx4_min = $calc_result ns"
      echo "   ###################################"
      if { $calc_result < [expr 5] } {
         echo "   #  Timing Check result: OK.       #"
         incr astc_check_path_num
         set astc_judge "OK"
      } else { 
         echo "   #  Timing Check result: NG.       #"
         incr astc_check_fail_num
         set astc_judge "NG"
      }
      echo "   ###################################"
      set astc_slack [expr [expr 5] - $calc_result ]
      echo "   Timing slack is [expr 5] - ($calc_result) = $astc_slack ns"
      echo "Kobetsu_RX23E_A_DSAD	,R_F_dsad_0_clk_osx4_dly	,$astc_slack	,$astc_judge,rise_dsad_0_clk_osx4_max-fall_dsad_0_clk_osx4_min  < [expr 5],\" $rise_dsad_0_clk_osx4_max - $fall_dsad_0_clk_osx4_min < [expr 5]\"" >> $ASTC_REP_DIR/Chk_summary_${COND}.csv
      if { $astc_worst_slack > $astc_slack } {
         set astc_worst_slack $astc_slack
      }
   }
   echo "--------------------------------------------------"
   echo "----- End   Timing check rule \"R_F_dsad_0_clk_osx4_dly\""
   echo "--------------------------------------------------"
  
proc get_obj_class { obj } {
   set class ""
   set class_cnt 0
   foreach obj_split [split $obj { +}] {
      if { [ regexp {^\$\{*([[:alnum:]_]+)\}*} $obj_split foo obj_name ] == 1 } {
         eval global $obj_name;
      }
   }
   set class_clk  [lindex [get_attribute [eval "get_clocks $obj -quiet "] object_class] 0]
   set class_port [lindex [get_attribute [eval "get_ports  $obj -quiet "] object_class] 0]
   set class_pin  [lindex [get_attribute [eval "get_pins   $obj -quiet "] object_class] 0]
   set class_net  [lindex [get_attribute [eval "get_nets   $obj -quiet "] object_class] 0]
   if { $class_clk != "" } {
      set class $class_clk
      incr class_cnt
   }
   if { $class_port != "" } {
      set class $class_port
      incr class_cnt
   }
   if { $class_pin != "" } {
      set class $class_pin
      incr class_cnt
   }
   if { $class_net != "" } {
      set class $class_net
      incr class_cnt
   }

   if { $class_cnt > 1 } {
      echo "  ---> Warning0001: class of object \"$obj\" is more than one. Please indicate class clearly."
   } elseif { $class_cnt == 0 } {
      error  "Class of object \"$obj\" is not found.\n       Does the object name \"$obj\" exist?"
   }
   return $class;
}

proc get_path_status { file_path } {
   set path_status_num 0;
   set path_status "";
   set fileID [ open $file_path ]
   while {! [eof $fileID] } {
      set rep_line [gets $fileID]
      if { [regexp {No constrained paths.} $rep_line] == 1 } {
         set path_status_num 1;
      } elseif { [regexp {No path.|No Paths.} $rep_line] == 1 } {
         set path_status_num 2;
      } elseif { [regexp {Path is unconstrained.} $rep_line] == 1 } {
         set path_status_num 3;
      } elseif { [regexp {Error} $rep_line] == 1 } {
         set path_status_num 4;
      } elseif { [regexp {slack} $rep_line] == 1 } {
         set path_status_num 5;
      } else {
      }
   }
   close $fileID


   if { $path_status_num == 5 } {
      set path_status "Constrainted"
   } elseif { $path_status_num == 1 } {
      set path_status "No const"
   } elseif { $path_status_num == 2 } {
      set path_status "No path"
   } elseif { $path_status_num == 3 } {
      set path_status "Unconstrained"
   } elseif { $path_status_num == 4 } {
      set path_status "Error"
   } else {
       echo "Error0003 : There are no timing reported results in \"$file_path\".";
   }
   return $path_status;
}


proc get_port_clk { port io edge dly_type file_path } {
   set port [get_attribute [eval "get_ports $port"] full_name]
   set fileID [ open $file_path ]
   set in_dly_flag 0
   set dly_status_flag ""
   set port_hit_flag 0
   set port_clocks ""
   set col_base 0
   while {! [eof $fileID] } {
      set col 0
      set rep_line [gets $fileID]
      set port_rep [lindex $rep_line 0];
      if { $port_rep == "Output" } {
         set dly_status_flag "O";
      } elseif { $port_rep == "Input" } {
         set dly_status_flag "I";
      } 
      if { $dly_status_flag == $io } {
          if { $port_rep == $port } {
             incr port_hit_flag;
             set col_base 1;
          } elseif { [regexp {^[\d\.]+$} $port_rep ] == 1} {
             incr port_hit_flag;
             set col_base 0;
          } else {
             set port_hit_flag 0;
          }
      }
      
      if { $port_hit_flag > 0 } {
         if { $dly_type == "max" } {
            set col_base [expr $col_base + 2 ];
            if { [regexp {rise}  $edge ] ==  1 } {
               if { [regexp {^[\d\.]+$} [lindex $rep_line $col_base ] ] == 1 } {
                   set port_clocks "$port_clocks [lindex $rep_line [expr $col_base+2]]"
               }
            } elseif { [regexp {fall}  $edge ] ==  1 } {
               if { [regexp {^[\d\.]+$} [lindex $rep_line [expr $col_base+1] ] ] == 1 } {
                   set port_clocks "$port_clocks [lindex $rep_line [expr $col_base+2]]"
               }
            } else {
               if { [regexp {^[\d\.]+$} [lindex $rep_line $col_base ] ] == 1 || [regexp {^[\d\.]+$} [lindex $rep_line [expr $col_base+1] ] ] == 1 } {
                   set port_clocks "$port_clocks [lindex $rep_line [expr $col_base+2]]"
               }
            }	
         } elseif { $dly_type == "min" } {
            set col_base [expr $col_base + 1 ];
            if { [regexp {rise}  $edge ] ==  1 } {
               if { [regexp {^[\d\.]+$} [lindex $rep_line $col_base ] ] == 1 } {
                   set port_clocks "$port_clocks [lindex $rep_line [expr $col_base+2]]"
               }
            } elseif { [regexp {fall}  $edge ] ==  1 } {
               if { [regexp {^[\d\.]+$} [lindex $rep_line [expr $col_base+1] ] ] == 1 } {
                   set port_clocks "$port_clocks [lindex $rep_line [expr $col_base+2]]"
               }
            } else {
               if { [regexp {^[\d\.]+$} [lindex $rep_line $col_base ] ] == 1 || [regexp {^[\d\.]+$} [lindex $rep_line [expr $col_base+1] ] ] == 1 } {
                   set port_clocks "$port_clocks [lindex $rep_line [expr $col_base+2]]"
               }
            }	
         }
      }
   }
   return $port_clocks;
}

proc check_inst_disable { inst file_path } {

   while {! [eof $fileID] } {
      set rep_line [gets $fileID]
      if { [regexp {^$inst\s+} $rep_line ] == 1 } {
         echo "debug4 $rep_line"
      }
   }
}

proc analyze_rep_cmd {rep_cmd} {
   global  timing_report_unconstrained_paths;
   set out_dir ".\/log_analyze_rep_cmd";
   set dly_type "max";
   set point_cnt 0;
   if { [file exists $out_dir] } {
       if { [file isdirectory $out_dir] } {

       } else {
          echo "  ---> Error0001 : file \"$out_dir\" exist.Directory for analyze_rep_cmd couldn't be generated";
       }
   } else {
       file mkdir $out_dir;
   }

   file delete -force $out_dir/*

   set path_status "";
   set thr_cnt 0;
   set cmd_cnt 0;
   set bracket_cnt 0;
   set bracket_flag 0;
   set from_point_flag 0;
   set from_class "";
   set from_point "";
   set from_edge "";
   set to_point_flag 0;
   set to_class "";
   set to_point "";
   set to_edge "";
   set thr_point_flag 0;
   set thr_point(0) ""
   set from_string "";
   set to_string "";
   set thr_string "";
   set rep_opt_other "";
   set rep_opt_all "";
   set bracket 0
   set rep_cmd_split_merge ""

   set rep_cmd_tmp ""
   foreach rep_cmd_split [split $rep_cmd { +}] {
      if { [ regexp {^\$\{*([[:alnum:]_]+)\}*} $rep_cmd_split foo cmd_name ] == 1 } {
         upvar $cmd_name val_local;
         set rep_cmd_tmp "$rep_cmd_tmp$val_local "
      } else {
         set rep_cmd_tmp "$rep_cmd_tmp$rep_cmd_split "
      }
   }
   
   foreach rep_cmd_split [split $rep_cmd_tmp { +}] {
      if { $rep_cmd_split != "" } {
         set rep_cmd_split_merge "$rep_cmd_split_merge $rep_cmd_split" 

         if { [regexp -all {\[} $rep_cmd_split ] > 0 } {
            set bracket [expr $bracket + [regexp -all {\[} $rep_cmd_split ]];
         }
         if { [regexp -all {\]} $rep_cmd_split] > 0 } {
            set bracket [expr $bracket - [regexp -all {\]} $rep_cmd_split ]];
         }
         if { $bracket == 0 } {
            set cmd_parts_array($cmd_cnt) $rep_cmd_split_merge;
            incr cmd_cnt;
            set rep_cmd_split_merge "";
         }
      }
   }
   set rep_cmd "";
   for { set i 1 } {$i < $cmd_cnt} { incr i } {
      set rep_cmd "$rep_cmd $cmd_parts_array($i)";
   }

   echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%";
   echo "%%% Analyze indicated path status of the following report command.";
   echo "%%% \"$rep_cmd\"";
   echo "%%% This script output information to analyze path.";
   echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%";
   echo "### Report files for analysis are temporary output to \"$out_dir\" directory."
   echo "### These files will be overwritten by next execution."
   # devide arguments 

   report_disable_timing -nosplit > $out_dir/report_disable_timing.log
   report_port -input_delay -output_delay -nosplit > $out_dir/report_port.log
   report_case_analysis -nosplit > $out_dir/report_case_analysis.log
   eval report_timing $rep_cmd;
   eval report_timing $rep_cmd > $out_dir/normal.rep;
   set path_status [get_path_status "$out_dir/normal.rep"];
   echo "  Report result of Object path	: $path_status.";

echo "### 1. Classify path options"

   if { $path_status == "Constrainted" } {
      echo "  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
      echo "  :: Info0001	: OK. The object path report is correctly output."
      echo "  :: 	      	  There is no need of analysis."
      echo "  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
      return;
   } elseif { $path_status == "Error" } {
      echo "  Please solve the error of report command itself."
      return;
   }

   if { [regexp {report_timing} $cmd_parts_array(0) ] != 1 } {
       echo "  ---> Error0002 : this procedure must be used with report_timing command. But it is used with \"$cmd_parts_array(0)\" command.";
   }

   for { set i 0 } {$i < $cmd_cnt} { incr i } {
      if { $i != 0 } {
         set rep_opt_all "$rep_opt_all $cmd_parts_array($i)";
      }
      if { [regexp {\-from|\-rise_from|-fall_from} $cmd_parts_array($i) from_edge ] == 1 } {
         set from_point_flag 1;
      } elseif { [regexp {\-to|\-rise_to|\-fall_to} $cmd_parts_array($i) to_edge  ] == 1 } {
         set to_point_flag 1;
      } elseif { [regexp {\-thr|-rise_thr|-fall_thr} $cmd_parts_array($i) thr_edge_tmp ] == 1 } {
         set thr_point_flag 1;
         set thr_string "";
      } elseif { $from_point_flag == 1 } {
         incr point_cnt;
         set bracket_cnt [expr $bracket_cnt + [regexp -all {\[} $cmd_parts_array($i)] ];
         if { $bracket_cnt > 0 } {
            set bracket_flag 1;
         }
         set bracket_cnt [expr $bracket_cnt - [regexp -all {\]} $cmd_parts_array($i)] ];
         set from_string "$from_string $cmd_parts_array($i)";
         if { $bracket_cnt == 0 } {
            if { $bracket_flag == 1 } {
               set from_point "$from_string";
            } else {
               set from_point "$cmd_parts_array($i)";
            }
echo "  from	: $from_point"
            set from_point_flag 0;
            set from_class [get_obj_class $from_point]
echo "  from class : $from_class"

         }
      } elseif { $to_point_flag == 1 } {
         incr point_cnt;
         set bracket_cnt [expr $bracket_cnt + [regexp -all {\[} $cmd_parts_array($i)] ];
         if { $bracket_cnt > 0 } {
            set bracket_flag 1;
         }
         set bracket_cnt [expr $bracket_cnt - [regexp -all {\]} $cmd_parts_array($i)] ];
         set to_string "$to_string $cmd_parts_array($i)";
         if { $bracket_cnt == 0 } {
            if { $bracket_flag == 1 } {
               set to_point "$to_string";
            } else {
               set to_point "$cmd_parts_array($i)";
            }
echo "  to	: $to_point"
            set to_point_flag 0;
            set to_class [get_obj_class "$to_point"]
echo "  to   class : $to_class"
         }
      } elseif { $thr_point_flag == 1 } {
         incr point_cnt;
         set bracket_cnt [expr $bracket_cnt + [regexp -all {\[} $cmd_parts_array($i)] ];
         if { $bracket_cnt > 0 } {
            set bracket_flag 1;
         }
         set bracket_cnt [expr $bracket_cnt - [regexp -all {\]} $cmd_parts_array($i)] ];
         set thr_string "$thr_string $cmd_parts_array($i)";
         if { $bracket_cnt == 0 } {
            if { $bracket_flag == 1 } {
               set thr_point($thr_cnt) "$thr_string";
            } else {
               set thr_point($thr_cnt) "$cmd_parts_array($i)";
            }
            set thr_edge($thr_cnt) $thr_edge_tmp
            set thr_point_flag 0;
            set thr_class($thr_cnt) [get_obj_class "$thr_string"];
echo "  thr$thr_cnt	: $thr_point($thr_cnt)"
            incr thr_cnt;
         }
      } elseif { $i > 0 } {
         if { [regexp {\-delay_type} $cmd_parts_array([expr $i-1])] == 1 } {
            set dly_type $cmd_parts_array($i);
         }
         set rep_opt_other "$rep_opt_other $cmd_parts_array($i)";
      }
   }
echo "  other	: $rep_opt_other"
echo "  delay_type	: $dly_type"
echo "  These $point_cnt points are indicated."
echo "### 2. Check report cmd with \"set timing_report_unconstrained_paths true\"."
if { $timing_report_unconstrained_paths	!= true } {
   uplevel {set timing_report_unconstrained_paths true};
   eval "report_timing $rep_opt_all -exceptions all"
   eval "report_timing $rep_opt_all -exceptions all" > $out_dir/unconst.rep
   set fileID [ open $out_dir/unconst.rep ]
   set exception_hit_flag 0
   set reason_hit_flag 0
   set false_hit_flag 0
   while {! [eof $fileID] } {
      set rep_line [gets $fileID];
      if { [regexp {The dominant exceptions are:} $rep_line ] == 1 } {
         set exception_hit_flag 1;
      } elseif { [regexp {The unconstrained reasons (except for false path) are:} $rep_line ] == 1 } {
         set reason_hit_flag 1;
      } elseif { [regexp {No Paths.} $rep_line ] == 1 } {
         echo "  ---> Object path is not exist."
         echo "       Case1: The path does not exist physically."
         echo "       Case2: The path is intercepted by set_case_analysis constraints."
         echo "       Case3: The path is intercepted by set_disable_timing constraints."
         echo "       Or other..."
      }
      if { [regexp {slack\s+\(} $rep_line ] == 1 } {
          echo "$rep_line"
      } elseif { [regexp {Path is unconstrained} $rep_line ] == 1 } {
          echo "$rep_line"
      }
      if { $exception_hit_flag == 1 } {
          echo $rep_line"
          if { [regexp {FALSE} $rep_line ] == 1 } {
             set false_hit_flag 1
          }
      }
   }
   close $fileID
   uplevel {set timing_report_unconstrained_paths false};
   if { $false_hit_flag == 1 } {
      echo "  Info0002	: false exception exists in object path."
   } else {
      echo "  Info0003	: false exception doesn't exist in object path."
   }
   if { $reason_hit_flag == 1 } {
      echo "  Info0004	: unconstrained reason exists in object path."
   }
} else {
   echo "  ---> Skipped. Because value timing_report_unconstrained_paths has already \"true\"." 
}
echo "### 3. Check start and end clocks.";
   if { $from_class != "clock" } {
      if { [regexp {\S} $from_class] == 1 } {
         set from_clk [get_attribute [get_attribute [eval "get_$from_class $from_point"] clocks -quiet] full_name];
         if { $from_clk != "" } {
            echo "  Clock of start point	: $from_clk";
         } else {
            echo "  Clock of start point	: Not found.";
         }
      } elseif { $thr_point(0) != "" } {
         if { [regexp {CLK} $thr_point(0) ] == 1 } {
            set from_clk [get_attribute [get_attribute [eval "get_$thr_class(0) $thr_point(0)"] clocks -quiet] full_name];
            if { $from_clk != "" } {
               echo "  Clock of 1st thr point	: $from_clk";
            } else {
               echo "  Clock of 1st thr point	: Not found.";
            }
         } else {
            echo "  Clock of start point	: Start point is not indicated.";
            echo "                      	  Also 1st through point \"$thr_point(0)\" is not clock pin.";
         }
      } else {
          echo "  Clock of start point	: Start point is not indicated.";
          echo "                	  Also through point is not indicated.";
      }
   } else {
      echo "  Clock of start point	: $from_point";
      if { $thr_cnt > 0 } {
         set thr_from_clks ""
         if { $thr_class(0) == "pin" } {
            set thr_from_clks [get_attribute [get_attribute [get_pins -of [get_cells -of_objects [eval "get_$thr_class(0) $thr_point(0)"] ] -filter "lib_pin_name==CLK" -quiet ] clocks -quiet] full_name];
         } elseif { $thr_class(0) == "port" } {
            set thr_from_clks [get_port_clk $thr_point(0) O $thr_edge(0) $dly_type $out_dir/report_port.log]
         }
         if { $thr_from_clks != "" } {
            set from_clk_hit_flag 0;
            set from_point [get_attribute [eval "get_clocks $from_point"] full_name]
            foreach thr_from_clk $thr_from_clks {
               if { $from_point == $thr_from_clk } {
                  set from_clk_hit_flag 1;
               }
            }
            if { $from_clk_hit_flag != 1 } {
               echo "  ---> Warning0001: -from clock \"$from_point\" indicated as endpoint is not related to first through point \"$thr_point(0)\"."
            } else {
               echo "  ---> Info0004	:  -from clock \"$from_point\" is related to first through point \"$thr_point(0)\"."
            }
         } 
      }
   }
   if { $to_class != "clock" } {
      if { [regexp {\S} $to_class] == 1 } { 
         if { $to_class == "port" } {
            set to_clk [get_port_clk $to_point O $to_edge $dly_type $out_dir/report_port.log]
         } else {
            set to_clk ""
            foreach_in_collection cell_pin [get_pins -of [get_cells -of_objects $to_point] ] {
               if { [get_attribute $cell_pin is_clock_pin ] == true } {
                  set to_clk "$to_clk [get_attribute [get_attribute $cell_pin clocks -quiet] full_name]";
               }
            }
         }
         if { $to_clk != "" } {
            echo "  Clock of end point	: $to_clk";
         } else {
            echo "  Clock of end point	: Not found.";
         }
      } else {
         echo "  Clock of end point	: Not indicated.";
         if { $thr_cnt > 0 } {
            if { [regexp {CLK} $thr_point([expr $thr_cnt-1]) ] == 1 && $thr_class([expr $thr_cnt-1]) == "pin" } {
               set to_clk [get_attribute [get_attribute [get_pins -of [get_cells -of_objects [eval "get_$thr_class([expr $thr_cnt-1]) $thr_point([expr $thr_cnt-1])"] ] -filter "lib_pin_name==CLK" -quiet] clocks -quiet] full_name];
            } elseif { $thr_class([expr $thr_cnt-1]) == "port" } {
               set to_clk [get_port_clk $thr_point([expr $thr_cnt-1]) O $thr_edge([expr $thr_cnt-1]) $dly_type $out_dir/report_port.log]
            } else {
               set to_clk ""
            }
            if { $to_clk != "" } {
               echo "  Clock of last thr point	: $to_clk";
            } else {
               echo "  Clock of last thr point	: Not found.";
            }
         }
      }
   } else {; # -to clock indicdated; 
      echo "  Clock of to point	: $to_point";
      if { $thr_cnt > 0 } {
         set thr_to_clks ""
         if { $thr_class([expr $thr_cnt-1]) == "pin" } {
            if { [get_attribute [get_cells -quiet -of [eval "get_$thr_class([expr $thr_cnt-1]) $thr_point([expr $thr_cnt-1])"]] is_hierarchical] != "true" } {
               set thr_to_clks [get_attribute [get_attribute [get_pins -of [get_cells -of_objects [eval "get_$thr_class([expr $thr_cnt-1]) $thr_point([expr $thr_cnt-1])"] ] -filter "lib_pin_name==CLK"] clocks -quiet] full_name];
            } else {
               echo "  ---> Warning0003: last through point is hierarchy pin. So, clock check is not executed for -to clock \"$to_point\"."
            }
         } elseif { $thr_class([expr $thr_cnt-1]) == "port" } {
            set thr_to_clks [get_port_clk $thr_point([expr $thr_cnt0]) O $thr_edge([expr $thr_cnt-1]) $dly_type $out_dir/report_port.log]
         }
         if { $thr_to_clks != "" } {
            set to_clk_hit_flag 0;
            set to_point [get_attribute [eval "get_clocks $to_point"] full_name]
            foreach thr_to_clk $thr_to_clks {
               if { $to_point == $thr_to_clk } {
                  set to_clk_hit_flag 1;
               }
            }
            if { $to_clk_hit_flag != 1 } {
               echo "  ---> Warning0002: -to clock \"$to_point\" indicated as endpoint is not related to last through point \"$thr_point([expr $thr_cnt-1])\"."
            } else {
               echo "  ---> Info0005	: -to clock \"$to_point\" is related to last through point \"$thr_point([expr $thr_cnt-1])\"."
            }
         } 
      }
   }
echo "### 4. Check indicated path point variation";
   if { $point_cnt > 1 } {
      set thr_cmd_all "";
      for { set i 0 } {$i < $thr_cnt} { incr i } {
         set thr_cmd_all "$thr_cmd_all $thr_edge($i) $thr_point($i)";
      }
      echo "  === Check A. report with excluding each points";
      if { $from_point != "" } {
         eval "report_timing  $thr_cmd_all $to_edge $to_point" > $out_dir/no-from.rep;
         set path_exc_status(from) [get_path_status "$out_dir/no-from.rep"]
         echo "    ---> Without from point	: $path_exc_status(from).";
      }
      if { $to_point != "" } {
         eval "report_timing  $from_edge $from_point $thr_cmd_all" > $out_dir/no-to.rep;
         set path_exc_status(to) [get_path_status "$out_dir/no-to.rep"]
         echo "    ---> Without to point	: $path_exc_status(to).";
      }
      set thr_cmd "";
      if { $thr_cnt > 0 } {
         for { set i 0 } {$i < $thr_cnt} { incr i } {
            set thr_cmd "";
            for { set j 0 } {$j < $thr_cnt} { incr j } {
               if { $i != $j } {
                  set thr_cmd "$thr_cmd $thr_edge($i) $thr_point($i)";
               }
            } 
            eval "report_timing  $from_edge $from_point $thr_cmd $to_edge $to_point" > $out_dir/no-thr$i.rep;
            set path_exc_status(thr$i) [get_path_status "$out_dir/no-thr$i.rep"]
            echo "    ---> Without thr point$i	: $path_exc_status(thr$i).";
         } 
      }

      echo "";
      echo "  === Check B. report with only including each points";

      set chkb_const_cnt 0
      if { $from_point != "" } {
         eval "report_timing  $from_edge $from_point" > $out_dir/from-only.rep;
         set path_inc_status(from) [get_path_status "$out_dir/from-only.rep"]
         echo "    ---> Only from point	: $path_inc_status(from).";
         if { $path_inc_status(from) == "Constrainted"} {
            incr chkb_const_cnt
         }
      }
      if { $to_point != "" } {
         eval "report_timing  $to_edge $to_point" > $out_dir/to-only.rep;
         set path_inc_status(to) [get_path_status "$out_dir/to-only.rep"];
         echo "    ---> Only to   point	: $path_inc_status(to).";
         if { $path_inc_status(to) == "Constrainted"} {
            incr chkb_const_cnt
         }
      }
      if { $thr_cnt > 0 } {
         if { $thr_cnt != 1 } {
            eval "report_timing  $thr_cmd_all" > $out_dir/thr-only.rep;
            set path_inc_status(thr_all) [get_path_status "$out_dir/thr-only.rep"];
            echo "    ---> Only thr  point	: $path_inc_status(thr_all).";
         }
         for { set i 0 } {$i < $thr_cnt} { incr i } {
            eval "report_timing  $thr_edge($i) $thr_point($i)" > $out_dir/thr$i-only.rep;
            set path_inc_status(thr$i) [get_path_status "$out_dir/thr$i-only.rep"];
            echo "    ---> Only thr  point$i	: $path_inc_status(thr$i).";
            if { $path_inc_status(thr$i) == "Constrainted"} {
               incr chkb_const_cnt
            }
         }
      }

      if { $from_point != "" } {
         if { $path_inc_status(from) != "Constrainted" && $path_exc_status(from) == "Constrainted" } {
            echo "   *** from \"$from_edge $from_point\" is doubtful."
         }
      }
      if { $to_point != "" } {
         if { $path_inc_status(to) != "Constrainted" && $path_exc_status(to) == "Constrainted" } {
            echo "   *** to \"$to_edge $to_point\" is doubtful."
         }
      }
      if { $thr_cnt > 0 } {
         for { set i 0 } {$i < $thr_cnt} { incr i } {
            if { $path_inc_status(thr$i) != "Constrainted" } {
               if { $path_exc_status(thr$i) == "Constrainted" } {
                  echo "   *** thr$i \"$thr_edge($i) $thr_point($i)\" is doubtful."
               }
            }
         }
      }
      if { $chkb_const_cnt == $point_cnt } {
         echo "   *** report of each points are correctly reported. The combination of these point is doubtful."
      }
   } else {
      echo "  ---> Skipped. Because indicated path point number is only $point_cnt." 
   }

#echo "### 5. Check fixed or disabled points around indicated points.";
#   if { $from_point != "" && $from_class != "clock" } {
#      echo "   ### check fanout of from point";
#      set from_fanout_all  [eval "all_fanout -from $from_point -flat -trace_arc all"];
#      set from_fanout_timing [eval "all_fanout -from $from_point -flat -trace_arc timing"];
#      echo $from_fanout_all > $out_dir/from_fanout_all.rep;
#      echo $from_fanout_timing > $out_dir/from_fanout_timing.rep;
#      set fixed_num [expr [sizeof_collection $from_fanout_all] - [sizeof_collection $from_fanout_timing]]
#      if { $fixed_num > 0 } {
#         foreach point_all [get_attribute $from_fanout_all full_name] {
#            set uniq_point_hit 0
#            foreach point_timing [get_attribute $from_fanout_timing full_name] {
#               if { $point_timing == $point_all } {
#                  incr uniq_point_hit
#               }
#            }
#            if { $uniq_point_hit == 0 } {
#               echo "$point_all" >> $out_dir/from_fanout_disabled.rep;
#            }
#         }
#         echo "    Warning0003 : There is a possiblity that several fanout of from point is disabled or fixed by case or disable settings."
#         echo "                  These points are reported to $out_dir/from_fanout_disabled.rep."
#      }
#   }
#   if { $to_point != ""  && $to_class != "clock" } {
#      echo "   ### check fanin of to point"
#      set to_fanin_all    [eval "all_fanin -to $to_point -flat -trace_arc all"];
#      set to_fanin_timing [eval "all_fanin -to $to_point -flat -trace_arc timing"];
#      echo [get_attribute $to_fanin_all full_name] > $out_dir/to_fanin_all.rep;
#      echo [get_attribute $to_fanin_timing full_name] > $out_dir/to_fanin_timing.rep;
#      set fixed_num [expr [sizeof_collection $to_fanin_all] - [sizeof_collection $to_fanin_timing]]
#      if { $fixed_num > 0 } {
#         foreach point_all [get_attribute $to_fanin_all full_name] {
#            set uniq_point_hit 0
#            foreach point_timing [get_attribute $to_fanin_timing full_name] {
#               if { $point_timing == $point_all } {
#                  incr uniq_point_hit
#               }
#            }
#            if { $uniq_point_hit == 0 } {
#               echo "$point_all" >> $out_dir/to_fanin_disabled.rep;
#            }
#         }
#         echo "    Warning0004 : There is a possiblity that several fanin of to point is disabled or fixed by case or disable settings."
#         echo "                  These points are reported to $out_dir/to_fanin_disabled.rep."
#      }
#   }
#   if { $thr_cnt > 0 } {
#      for { set i 0 } {$i < $thr_cnt} { incr i } {
#         regexp {\-(rise_|fall_|)} $thr_edge($i) thr_edge_parts
#         echo "  === check fanout of thr${i} point"
#         set thr_fanout_all    [eval "all_fanout -from $thr_point($i) -flat -trace_arc all"];
#         set thr_fanout_timing [eval "all_fanout -from $thr_point($i) -flat -trace_arc timing"];
#         echo [get_attribute $thr_fanout_all full_name] > $out_dir/thr${i}_fanout_all.rep;
#         echo [get_attribute $thr_fanout_timing full_name] > $out_dir/thr${i}_fanout_timing.rep;
#         set fixed_num [expr [sizeof_collection $thr_fanout_all] - [sizeof_collection $thr_fanout_timing]]
#         echo "    ---> $fixed_num disabled points exist."
#         if { $fixed_num > 0 } {
#            foreach point_all [get_attribute $thr_fanout_all full_name] {
#               set uniq_point_hit 0
#               foreach point_timing [get_attribute $thr_fanout_timing full_name] {
#                  if { $point_timing == $point_all } {
#                     incr uniq_point_hit
#                  }
#               }
#               if { $uniq_point_hit == 0 } {
#                  echo "$point_all" >> $out_dir/thr${i}_fanout_disabled.rep;
#               }
#            }
#            echo "    Warning0005 : There is a possiblity that several fanout of thr${i} point is disabled or fixed by case or disable settings."
#            echo "                  These points are reported to $out_dir/thr${i}_fanout_disabled.rep."
#         }
#         echo "  === check fanin  of thr${i} point"
#         set thr_fanin_all       [eval "all_fanin  -to $thr_point($i) -flat -trace_arc all"];
#         set thr_fanin_timing    [eval "all_fanin  -to $thr_point($i) -flat -trace_arc timing"];
#         echo [get_attribute $thr_fanin_all full_name] > $out_dir/thr${i}_fanin_all.rep;
#         echo [get_attribute $thr_fanin_timing full_name] > $out_dir/thr${i}_fanin_timing.rep;
#         set fixed_num [expr [sizeof_collection $thr_fanin_all] - [sizeof_collection $thr_fanin_timing]]
#         echo "    ---> $fixed_num disabled points exist."
#         if { $fixed_num > 0 } {
#            foreach point_all [get_attribute $thr_fanin_all full_name] {
#               set uniq_point_hit 0
#               foreach point_timing [get_attribute $thr_fanin_timing full_name] {
#                  if { $point_timing == $point_all } {
#                     incr uniq_point_hit
#                  }
#               }
#               if { $uniq_point_hit == 0 } {
#                  echo "$point_all" >> $out_dir/thr${i}_fanin_disabled.rep;
#               }
#            }
#            echo "    Warning0006 : There is a possiblity that several fanin of thr${i} point is disabled or fixed by case or disable settings."
#            echo "                  These points are reported to $out_dir/thr${i}_fanin_disabled.rep."
#         }
#      }
#   }
#
echo "###### End analyze_rep_cmd script.";
}
#-----------------------------------------------------------
#-- start define procedure
#-----------------------------------------------------------
   proc astc_path_skew_calc { paths } {
      set path_max  0;
      set path_min  10000;
      foreach path $paths {
         if {$path > $path_max} {
            set path_max $path
         }
         if {$path < $path_min} {
            set path_min $path
         }
         set path_skew [expr $path_max - $path_min]
      }
      return ($path_skew);
   }
   proc astc_path_max_calc { paths } {
      set path_max  -10000;
      foreach path $paths {
         if {$path > $path_max} {
            set path_max $path
         }
      }
      return ($path_max);
   }
   proc astc_path_min_calc { paths } {
      set path_min  10000;
      foreach path $paths {
         if {$path < $path_min} {
            set path_min [expr $path ]
         }
      }
      return ($path_min);
   }
   proc astc_path_err_calc { path_errors } {
      set err_flag  0;
      foreach path_err $path_errors {
         set err_flag [expr $err_flag + $path_err]
      }
      return ($err_flag);
   }
#-----------------------------------------------------------
#-- end   define procedure
#-----------------------------------------------------------
proc rep_exec_time { rst_flag } {
   # This procedure measure interval time between execution.

   global ciesta_sec_start_1st;
   global ciesta_sec_start;
   global ciesta_sec_end;
   set sec 0;
   if { ![info exist ciesta_sec_end] } {
      uplevel "set ciesta_sec_end \"0\"";
   } 
   uplevel "set ciesta_sec_start $ciesta_sec_end";
   uplevel "set ciesta_sec_end [clock seconds]";

   if { $rst_flag == "reset" } {
      set ciesta_sec_start "0"
   }

   global ciesta_sec_end;
   set day  "00";
   set hour "00";
   set min  "00";
   set sec  "00";
   if { $ciesta_sec_start != 0 } {
      set sec [expr $ciesta_sec_end - $ciesta_sec_start];
      set day [expr int($sec / (60*60*24))];
      set sec [expr fmod($sec, 60*60*24)];
      set hour [expr int($sec / (60*60))];
      set sec [expr fmod($sec, 60*60)];
      set min [expr int($sec / 60)];
      set sec [expr int(fmod($sec, 60))];
      set time_com "${day}d:${hour}h:${min}m:${sec}s";

      set sec [expr $ciesta_sec_end - $ciesta_sec_start_1st];
      set day [expr int($sec / (60*60*24))];
      set sec [expr fmod($sec, 60*60*24)];
      set hour [expr int($sec / (60*60))];
      set sec [expr fmod($sec, 60*60)];
      set min [expr int($sec / 60)];
      set sec [expr int(fmod($sec, 60))];
      set total_time_com "${day}d:${hour}h:${min}m:${sec}s";
      echo "   \[Execution time :  Interval=$time_com, Total=$total_time_com\]";

   } else {
      uplevel "set ciesta_sec_start_1st $ciesta_sec_end";
      echo "   ### rep_exec_time procedure was reset by the execution of \"rep_exec_time {reset}\".";
      echo "   ### Interval time output from next execution.";
      echo "   ### Interval: Time from before execution,  Total: Total time from reset.";
   }
}
