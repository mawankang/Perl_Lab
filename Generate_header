#!/usr/bin/perl -w
use strict;
use POSIX;
# POSIX::strftime , which implements more character sequences compatible with GNU systems
# %m The month as a decimal number (range 01 to 12).
# %d The day of the month as a decimal number (range 01 to 31).
# %Y The year as a decimal number including the century.
my $cur_time=strftime("%m/%d/%Y",localtime());
my $file_name;
my $tab=" "x4;
#pass arg to file_name
if (@ARGV == 1) {
   $file_name=$ARGV[0];
  }
else {
 &help_message();
 }
 
open(LOG,">",$file_name) or die "cannot open $file_name for writting \n";
my str="";
str.="#!/usr/bin/perl -w\n";
str.="use strict;\n";
str.="#----------------------------------------------------";
str.="#File_name  :  $file_name                          \n";
str.="#Description:                                      \n
                                                         \n
                                                         \n";
str.="#Author:                                           \n";
str.="#$cur_time                                         \n";
str.="#----------------------------------------------------";
print LOG $str;
close (LOG);
print "\nHeader has been generated for $file_name";
sub help_message{
print "\n Usage: perl $0 file_name\n\n";
exit;
}

#!/bin/tcsh
# the next line restarts using tclsh \
exec tclsh "$0" "$*"

#foreach args ${argv} {
#    ### OverWrite ###
#    if {[regexp -nocase -- {^-f} ${args}]} {
#	set  overwrite	"1"
#
#    ### block ###
#    } else {
#	set target  ${args}
#    }
#}

#argu pass step1: exec tclsh $0 $*
#	        aline args  $0 $* in tcsh with tclsh
#tips: $* is one string with blank as seperator
#	$@ is several strings,only bash support
#tips $* seems have done the translation from ../a* to ../a1 ../a2 ../a3
#puts "$argv"
set targets   ${argv}


proc get_abspath { args } {
    #remove '{' and '}' 
    set targets_temp $args
    set targets_temp [regsub  -all {\{} $targets_temp {}]
    set targets_temp [regsub  -all {\}} $targets_temp {}]
    set abs_paths  ""
    foreach target [split $targets_temp] {
	  set root_dir [pwd]
   	   ### is directory ###
   	  if {[file isdirectory ${target}]} {
   	      cd ${target}
   	      set abs_path [pwd]
   	  }

   	  ### is file ###
   	  if {[file isfile ${target}]} {
   	      set t_dir   [file dirname ${target}]
   	      set t_file  [file tail ${target}]

   	      cd ${t_dir}
   	      set abs_path [pwd]
   	      set abs_path ${abs_path}/${t_file}
   	  }
   	  
   	  ### Return ###
	  puts "$abs_path"
	  #lappend abs_paths ${abs_path}
   	  cd ${root_dir}
    }
   #puts [llength ${abs_paths}]
   #return  ${abs_paths}
}
puts [get_abspath $targets]



set softtabstop=4
nmap <C-g> <ESC>:echo expand('%:p')<CR>
iab py #!/usr/local/bin/python2.7
iab csh #!/bin/tcsh

#!/usr/local/bin/python2.7
import csv
import sys
import os
sys.path.append('/svhome/os_mawa/py/my_lib/xlwt-1.3.0')
import xlwt
#
myexcel = xlwt.Workbook()
#
csvBaseDir = ''
csvList = os.listdir(csvBaseDir)

#P1--for each csv
testfile = open('tf',"w")
for cf in csvList:
    #abs path
    cfAbs = os.path.join(csvBaseDir,cf)
    csvfile = open(cfAbs,"r")

    #print cfAbs
    mysheet = myexcel.add_sheet(cf)
    #
    reader = csv.reader(csvfile)
    l = 0
    #line is a list
    for line in reader:
	#print(line)
	#testfile.write(line)
        r = 0
        #
        for i in line:
            #print l,r 
            # write sheet
            mysheet.write(l,r,i)
            r=r+1
        l=l+1
#P2--save to sheet 
#
myexcel.save(csvBaseDir+"/myexcel.xls")
testfile.close()


#!/bin/csh -vx
#csh -vx show the command before running to help debug

#just to check syntax
#csh -n $0

#argv
if ($#argv < 2) then
    echo "Sorry, but you entered too few parameters"
    echo "usage:  $0 arg1 arg2
    exit
endif
set arg1 = $1
set arg2 = #2

foreach i ($*)
   echo $i
end
  
#execute commands
echo "Hello there `whoami`.  How are you today?"
echo "You are currently using `hostname` and the time is `date`"
echo "Your directory is `pwd`"
whoami
hostname
date
pwd

#var
set name = Mark
echo $name
set name = "Mark Meyer" # if the string has space, must use ""
echo $name
# it means set to NULL
set name =
unset name
# get user input
set x = $< 
set current_user = `whoami`

#buildin vars
echo $user      # who am I?
echo $status    # a numeric variable, usually used to retun error codes

#Arithmetic variables
@ i = 2
@ k = ($x - 2) * 4
@ k = $k + 1
@ i--
@ i++

#array
set name = (mark sally kathy tony)
echo $#name    # num of the array
echo $name[1]
echo $name[4]
echo $name[2-3]
echo $name[2-]        # all elements from 2 to the end
echo $name[1-3]
echo $name[$i]
set name = ($name doran)
set name = (doran $name)
set name = ($name[1-2] alfie $name[3-])
shift name  # get rid of the frist element of the array
shift #if no argument is given, it will get rid of argv

#Expressions and operators
==        equal     (either strings or numbers)
!=        not equal     (either strings or numbers)
=~        string match
!~        string mismatch
<=        numerical less than or equal to
>=        numerical greater than or equal to
>         numerical greater than
<         numerical less than

-e file           file merely exists (may be protected from user)
-r file           file exists and is readable by user
-w file           file is writable by user
-x file           file is executable by user
-o file           file is owned by user
-z file           file has size 0
-f file           file is an ordinary file
-d file           file is a directory

!   -- negate                
&&  -- logical and
||  -- logical or

#if-else
# run cmd as if expression
if ({grep -s junk $1}) then 
   echo "We found junk in file $1"
endif
# check if the var is defined
if ($?dirname) then
    ls $dirname
endif

if (-e somefile) then
 grep $1 somefile
else
 echo "Grievous error!  Database file does not exist".
endif

#foreach
foreach i (*)
    if (-f $i) then
        echo "============= $i ==================="
        head $i
    endif
    if (-d $i) then
        (cd $i; headers)
    endif
end

#while
while ($#argv > 0)
    grep $something $argv[1]
end

@ n = 5
while ($n)
     # do something
     @ n--
end

#switch-case
switch ($argv[$i])
 case quit:
        break        # leave the switch statement
 case list:
        ls
        breaksw
 case delete:
 case erase:
        @ k = $i + 1
        rm $argv[$k]
        breaksw
endsw
   
#here document
grep $i <<HERE
John Doe   101 Surrey Lane    London, UK    5E7 J2K
Angela Langsbury   99 Knightsbridge, Apt. K4     Liverpool
John Major  10 Downing Street  London
HERE

cat > tempdata <<ENDOFDATA
53.3 94.3 67.1
48.3 01.3 99.9
42.1 48.6 92.8
ENDOFDATA

exit 0
#
set prompt = "`hostname`:`pwd`>"
alias cd 'chdir \!*; ls; set prompt = "`hostname`:`pwd`>"'
